


<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Inkling Reference - Bonsai</title>
    <style>
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight .gh {
  color: #999999;
}
.highlight .sr {
  color: #f6aa11;
}
.highlight .go {
  color: #888888;
}
.highlight .gp {
  color: #555555;
}
.highlight .gs {
}
.highlight .gu {
  color: #aaaaaa;
}
.highlight .nb {
  color: #f6aa11;
}
.highlight .cm {
  color: #75715e;
}
.highlight .cp {
  color: #75715e;
}
.highlight .c1 {
  color: #75715e;
}
.highlight .cs {
  color: #75715e;
}
.highlight .c, .highlight .cd {
  color: #75715e;
}
.highlight .err {
  color: #960050;
}
.highlight .gr {
  color: #960050;
}
.highlight .gt {
  color: #960050;
}
.highlight .gd {
  color: #49483e;
}
.highlight .gi {
  color: #49483e;
}
.highlight .ge {
  color: #49483e;
}
.highlight .kc {
  color: #66d9ef;
}
.highlight .kd {
  color: #66d9ef;
}
.highlight .kr {
  color: #66d9ef;
}
.highlight .no {
  color: #66d9ef;
}
.highlight .kt {
  color: #66d9ef;
}
.highlight .mf {
  color: #ae81ff;
}
.highlight .mh {
  color: #ae81ff;
}
.highlight .il {
  color: #ae81ff;
}
.highlight .mi {
  color: #ae81ff;
}
.highlight .mo {
  color: #ae81ff;
}
.highlight .m, .highlight .mb, .highlight .mx {
  color: #ae81ff;
}
.highlight .sc {
  color: #ae81ff;
}
.highlight .se {
  color: #ae81ff;
}
.highlight .ss {
  color: #ae81ff;
}
.highlight .sd {
  color: #e6db74;
}
.highlight .s2 {
  color: #e6db74;
}
.highlight .sb {
  color: #e6db74;
}
.highlight .sh {
  color: #e6db74;
}
.highlight .si {
  color: #e6db74;
}
.highlight .sx {
  color: #e6db74;
}
.highlight .s1 {
  color: #e6db74;
}
.highlight .s {
  color: #e6db74;
}
.highlight .na {
  color: #a6e22e;
}
.highlight .nc {
  color: #a6e22e;
}
.highlight .nd {
  color: #a6e22e;
}
.highlight .ne {
  color: #a6e22e;
}
.highlight .nf {
  color: #a6e22e;
}
.highlight .vc {
  color: #ffffff;
}
.highlight .nn {
  color: #ffffff;
}
.highlight .nl {
  color: #ffffff;
}
.highlight .ni {
  color: #ffffff;
}
.highlight .bp {
  color: #ffffff;
}
.highlight .vg {
  color: #ffffff;
}
.highlight .vi {
  color: #ffffff;
}
.highlight .nv {
  color: #ffffff;
}
.highlight .w {
  color: #ffffff;
}
.highlight {
  color: #ffffff;
}
.highlight .n, .highlight .py, .highlight .nx {
  color: #ffffff;
}
.highlight .ow {
  color: #f92672;
}
.highlight .nt {
  color: #f92672;
}
.highlight .k, .highlight .kv {
  color: #f92672;
}
.highlight .kn {
  color: #f92672;
}
.highlight .kp {
  color: #f92672;
}
.highlight .o {
  color: #f92672;
}
    </style>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
    <link href="../stylesheets/screen.css" rel="stylesheet" media="screen" />
    <link href="../stylesheets/print.css" rel="stylesheet" media="print" />
	  <link href="../stylesheets/test.css" rel="stylesheet" media="screen" />
    <link href="../favicon.ico" rel="icon" type="image/ico" />
      <script src="../javascripts/all.js"></script>
	
	  <!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-WVB6MG2');</script>
<!-- End Google Tag Manager -->
  </head>

  <body class="references references_inkling-reference" data-languages="[]">
	  
	  
	  <!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WVB6MG2"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) --> 

  <div id="flex-container">

	<nav id="primary-nav">



	<div id="logo"> <a href="../"><img class="bonsai-logo" src="../images/bonsai-logo.svg"></a></div>

	<label for="drop" class="toggle"><img class="menu-ham" src="../images/menu.svg"></label>
	<input type="checkbox" id="drop" />

	<ul class="menu">

		<li class="header_menu_item "> <a href="../guides/getting-started.html">Quick Start</a></li>

		<li class="header_menu_item"> <!-- First Tier Drop Down --> <label for="drop-1" class="toggle">Tutorials +</label><a  href="#">Tutorials</a>
			<input type="checkbox" id="drop-1"/>
			<ul id="tutorials">
				<li class=""> <a href="../guides/cli-install-guide.html">Install the CLI</a>  </li>
				<li class=""> <a href="../guides/sdk-install-guide.html">Install the SDK</a>  </li>
				<li class=""> <a href="../guides/local-dev-guide.html">Run the Platform Locally</a>  </li>
				<li class=""> <a href="../guides/jupyter-api-guide.html">Use Bonsai's API with Jupyter</a>  </li>
			</ul>
		</li>

		<li class="header_menu_item"> <!-- First Tier Drop Down --> <label for="drop-2" class="toggle">Guides +</label><a  href="#">Guides</a>
			<input type="checkbox" id="drop-2"/>
			<ul id="guides">
				<li class=""> <a href="../guides/simulation-guide.html">Learn About Simulation Requirements</a>  </li>
				<li class=""> <a href="../guides/inkling-guide.html">Learn the Inkling Language</a>  </li>
				<li class=""> <a href="../guides/ai-engine-guide.html">Understand AI Engine Components</a>  </li>
				<li class=""> <a href="../guides/web-graphs-guide.html">Understand BRAIN Graphs</a>  </li>
			</ul>
		</li>

		<li class="header_menu_item"> <!-- First Tier Drop Down --> <label for="drop-3" class="toggle">References +</label><a  href="#">References</a>
			<input type="checkbox" id="drop-3"/>
			<ul id="references">
				<li class=""> <a href="api-reference.html">API Reference</a>  </li>
				<li class=""> <a href="cli-reference.html">CLI Reference</a>  </li>
				<li class="selected"> <a href="inkling-reference.html">Inkling Reference</a>  </li>
				<li class=""> <a href="library-reference.html">Library Reference</a>  </li>
				<li class=""> <a href="simulator-reference.html">Simulator Reference</a>
			</ul> 
		</li>

		<li class="header_menu_item "> <a href="../examples.html">Examples</a></li>

		<li>
			<input type="search" id="docs-search" placeholder="Search Bonsai Docs">
		</li>


	</ul>

</nav>


	<div id="main-wrapper">

    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="../images/navbar.png" alt="Navbar" />
      </span>
    </a>
    <div class="tocify-wrapper">

        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <div class="page-title">Inkling Reference</div>
      <div id="toc">
      </div>
      
			 
<ul class="toc-footer">

<li><a href='https://bons.ai'>Bonsai Home</a></li>
<li><a href='https://beta.bons.ai'>BRAIN Dashboard</a></li>
<li><a href='https://github.com/BonsaiAI/slate'>Contribute to the Docs</a></li>
<li><a href='http://pages.bons.ai/apply.html'>Apply for Bonsai Platform Preview</a></li>
<li><a href='https://bons.ai/contact-us#contact-page-form'>Contact Us</a></li>

</ul>
       
        
	   <div class="cc-bottom">
	
	<div class="toc-footer bottom cc-info">

		<a href='https://creativecommons.org/licenses/by-sa/4.0/' class="cc-icon-width" >
			<svg class="cc" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
			viewBox="0 0 70.7 13.4" style="enable-background:new 0 0 70.7 13.4;" xml:space="preserve">

				<g>

				<g>
				<circle class="st0" cx="6.8" cy="6.7" r="6.1"/>
				<path d="M6.7,0c1.9,0,3.5,0.7,4.8,2c0.6,0.6,1.1,1.4,1.4,2.2c0.3,0.8,0.5,1.7,0.5,2.6c0,0.9-0.2,1.8-0.5,2.6
				c-0.3,0.8-0.8,1.5-1.4,2.1c-0.7,0.6-1.4,1.1-2.2,1.5c-0.8,0.3-1.7,0.5-2.6,0.5S5,13.3,4.2,12.9c-0.8-0.3-1.5-0.8-2.2-1.5
				s-1.1-1.4-1.5-2.2S0,7.6,0,6.7C0,5.8,0.2,5,0.5,4.2S1.3,2.6,2,2C3.3,0.7,4.8,0,6.7,0z M6.7,1.2c-1.5,0-2.8,0.5-3.9,1.6
				C2.3,3.4,1.9,4,1.6,4.6C1.4,5.3,1.2,6,1.2,6.7c0,0.7,0.1,1.4,0.4,2.1c0.3,0.7,0.7,1.3,1.2,1.8c0.5,0.5,1.1,0.9,1.8,1.2
				c0.7,0.3,1.4,0.4,2.1,0.4c0.7,0,1.4-0.1,2.1-0.4c0.7-0.3,1.3-0.7,1.8-1.2c1-1,1.6-2.3,1.6-3.9c0-0.7-0.1-1.4-0.4-2.1
				c-0.3-0.7-0.7-1.3-1.2-1.8C9.5,1.8,8.2,1.2,6.7,1.2z M6.6,5.6L5.7,6.1C5.6,5.9,5.5,5.7,5.4,5.6C5.3,5.6,5.1,5.5,5,5.5
				c-0.6,0-0.9,0.4-0.9,1.2c0,0.4,0.1,0.6,0.2,0.9C4.5,7.8,4.7,7.9,5,7.9c0.4,0,0.7-0.2,0.8-0.6l0.8,0.4C6.5,8.1,6.2,8.3,5.9,8.5
				c-0.3,0.2-0.7,0.3-1,0.3c-0.6,0-1.1-0.2-1.5-0.6C3.1,7.9,2.9,7.4,2.9,6.7c0-0.6,0.2-1.1,0.6-1.5c0.4-0.4,0.8-0.6,1.4-0.6
				C5.7,4.6,6.3,5,6.6,5.6z M10.5,5.6L9.6,6.1C9.5,5.9,9.4,5.7,9.3,5.6C9.1,5.6,9,5.5,8.9,5.5C8.3,5.5,8,5.9,8,6.7
				c0,0.4,0.1,0.6,0.2,0.9c0.2,0.2,0.4,0.3,0.7,0.3c0.4,0,0.7-0.2,0.8-0.6l0.8,0.4c-0.2,0.3-0.4,0.6-0.7,0.8c-0.3,0.2-0.7,0.3-1,0.3
				c-0.6,0-1.1-0.2-1.5-0.6C7,7.9,6.8,7.4,6.8,6.7c0-0.6,0.2-1.1,0.6-1.5c0.4-0.4,0.8-0.6,1.4-0.6C9.6,4.6,10.2,5,10.5,5.6z"/>
				</g>

				</g>
			</svg>
		</a>
		
		<a href='https://creativecommons.org/licenses/by-sa/4.0/'>Content:
		CC-BY-SA </a>
		
	</div>

</div>

    </div>
	      
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        
          <h1 id="inkling-overview">Inkling Overview</h1>
<pre class="highlight plaintext"><code>#######################################################
# Inkling Code and Syntax snippets will be shown here #
#######################################################
</code></pre>
<p>This reference contains comprehensive specifications and usage for the Inkling language, Bonsai’s special purpose programming language for training AI.</p>

<p>Inkling is a declarative, strongly typed language that provides a layer of
abstraction between the Inkling programmer and the vast and dynamic set of AI
algorithms that require expertise in machine learning. Inkling allows you to
focus at a conceptual level on what you want the machine to learn. That is why this model of
programming is called machine teaching. </p>

<aside class="notice">
EMACS USERS: There is an inkling-mode for local development found on <a href="https://github.com/BonsaiAI/inkling-mode">Bonsai&rsquo;s GitHub</a>
</aside>

<p>An Inkling file contains the <a href="#concepts">concepts</a> (what you want to teach the AI), a set of
<a href="#schemas">schemas</a> (which describe the data) and the <a href="#curriculums">curriculums</a> (how you want to teach the concepts) necessary to train your BRAIN.
Training your BRAIN will also require a <a href="#simulators">simulator</a>. Python simulators are
introduced in the <a href="../guides/getting-started.html#what-is-a-simulator">Quick Start</a>.</p>

<h3 id="purpose">Purpose</h3>

<p>The purpose of the Inkling Reference is to give you the level of detailed
specification you need to write valid Inkling code. 
The syntax for Inkling statements is available here. 
This document also contains
examples and explanation so that you can understand Inkling better. </p>

<h3 id="functionality">Functionality</h3>

<p>Use the Inkling Reference for quick lookups while coding and also for deep dives
into subjects like schema conformance and range expressions.</p>

          <h1 id="lexical-structure">Lexical Structure</h1>

<p>The lexical structure of Inkling includes these lexical elements:</p>

<ul>
<li><a href="#keywords"><code class="prettyprint">keyword</code></a>: the keyword set consists of the words that Inkling reserves for its own use.</li>
<li><a href="#identifiers"><code class="prettyprint">identifier</code></a>: user defined names in Inkling. For example, concept names.</li>
<li><a href="#literals"><code class="prettyprint">literal</code></a>: Inkling supports numeric and string literals.</li>
<li><a href="#operators"><code class="prettyprint">operator</code></a>: Inkling supports operators such as math operators and grouping operators.</li>
<li><a href="#comments"><code class="prettyprint">comment</code></a>: specifies comment format.</li>
</ul>

<h2 id="keywords">Keywords</h2>

<p>Here is the set of keywords in the Inkling language. These words are reserved
for use by Inkling and cannot be used as names in your program. </p>

<p><strong>Keywords Table</strong></p>

<table><thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead><tbody>
<tr>
<td>action</td>
<td>and</td>
<td>as</td>
<td>Bool</td>
</tr>
<tr>
<td>Byte</td>
<td>concept</td>
<td>configure</td>
<td>constrain</td>
</tr>
<tr>
<td>copy</td>
<td>curriculum</td>
<td>data</td>
<td>datastore</td>
</tr>
<tr>
<td>debug</td>
<td>Double</td>
<td>easy</td>
<td>end</td>
</tr>
<tr>
<td>expect</td>
<td>experimental</td>
<td>external</td>
<td>false</td>
</tr>
<tr>
<td>feeds</td>
<td>Float32</td>
<td>Float64</td>
<td>follows</td>
</tr>
<tr>
<td>format</td>
<td>from</td>
<td>generator</td>
<td>hard</td>
</tr>
<tr>
<td>import</td>
<td>in</td>
<td>input</td>
<td>Int16</td>
</tr>
<tr>
<td>Int32</td>
<td>Int64</td>
<td>Int8</td>
<td>interface</td>
</tr>
<tr>
<td>into</td>
<td>is</td>
<td>lesson</td>
<td>let</td>
</tr>
<tr>
<td>Luminance</td>
<td>Matrix</td>
<td>maximize</td>
<td>medium</td>
</tr>
<tr>
<td>minimize</td>
<td>not</td>
<td>objective</td>
<td>or</td>
</tr>
<tr>
<td>output</td>
<td>predicts</td>
<td>schema</td>
<td>select</td>
</tr>
<tr>
<td>send</td>
<td>simulator</td>
<td>state</td>
<td>stream</td>
</tr>
<tr>
<td>String</td>
<td>test</td>
<td>train</td>
<td>true</td>
</tr>
<tr>
<td>UInt16</td>
<td>UInt32</td>
<td>UInt64</td>
<td>UInt8</td>
</tr>
<tr>
<td>unit</td>
<td>until</td>
<td>using</td>
<td>validate</td>
</tr>
<tr>
<td>where</td>
<td>with</td>
<td>yield</td>
<td></td>
</tr>
</tbody></table>

<aside class="notice">
Most of these keywords are used by the currently supported Inkling version.
A few are not used in the currently supported Inkling version and are
reserved for future development such as Byte, Matrix, minimize, and String.
</aside>

<h2 id="identifiers">Identifiers</h2>
<pre class="highlight inkling tab-inkling--code"><code>    <span class="mi">1</span><span class="nx">st_name</span>        <span class="c1"># invalid identifier</span>
    <span class="o">-</span><span class="nx">primary</span><span class="o">-</span><span class="nx">key</span>    <span class="c1"># invalid identifier</span>
    <span class="nx">remember_me</span><span class="p">?</span>    <span class="c1"># invalid identifier</span>
</code></pre>
<p>An Inkling identifier (user defined name) must begin with an underscore or
letter, followed by any combination of alphanumeric characters and underscore.</p>

<h2 id="literals">Literals</h2>

<p>Inkling supports numeric literals (floating point and integer). </p>
<pre class="highlight inkling tab-inkling--code"><code>   <span class="o">+</span><span class="mi">999</span>
   <span class="o">-</span><span class="mi">3</span>
    <span class="mi">77</span>
</code></pre>
<ul>
<li><strong>Integer Literals</strong></li>
</ul>

<p>Integer literals are a string of digits with an optional sign and no decimal
point.</p>
<pre class="highlight inkling tab-inkling--code"><code> <span class="mf">12.0</span><span class="p">,</span> <span class="p">.</span><span class="mi">5</span>        <span class="c1"># Float32 floating point literal</span>
 <span class="mi">1</span><span class="nx">e7</span><span class="p">,</span> <span class="mi">9</span><span class="nx">e0</span>        <span class="c1"># Float64 (double) floating point literal</span>
 <span class="mf">13.0f</span><span class="mi">7</span><span class="p">,</span> <span class="p">.</span><span class="mi">3</span><span class="nx">f</span><span class="o">+</span><span class="mi">2</span>   <span class="c1"># Float32 floating point literal</span>
</code></pre>
<ul>
<li><strong>Floating Point Literals</strong></li>
</ul>

<p>Floating point literals can be Float32 or Float64 (double). An example is shown for
some floating point literals.</p>

<h2 id="operators">Operators</h2>

<p>The operator category includes mathematical, relational, and logical operators as well as
paired grouping operators like <code class="prettyprint">{</code> and <code class="prettyprint">}</code>. </p>

<p><strong>Operators Table</strong></p>

<table><thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead><tbody>
<tr>
<td>&lt;=</td>
<td>&lt;</td>
<td>==</td>
<td>=&gt;</td>
<td>=</td>
<td>&gt;=</td>
</tr>
<tr>
<td>-</td>
<td>,</td>
<td>:</td>
<td>!=</td>
<td>/</td>
<td>..</td>
</tr>
<tr>
<td>(</td>
<td>)</td>
<td>[</td>
<td>]</td>
<td>{</td>
<td>}</td>
</tr>
<tr>
<td>+</td>
<td>and</td>
<td>not</td>
<td>or</td>
<td></td>
<td></td>
</tr>
</tbody></table>

<h2 id="comments">Comments</h2>
<pre class="highlight inkling tab-inkling--code"><code>  <span class="c1"># this is a comment</span>
</code></pre>
<ul>
<li>An Inkling comment begins after the character <strong>#</strong> and extends to the end of the line.</li>
</ul>

          <h1 id="concepts">Concepts</h1>

<p>The <code class="prettyprint">concept</code> keyword declares an abstract concept that is to be learned by the system. It could be a feature (such as a curvy line in an image) or a goal (such as high score in a game).  Ultimately, a concept takes the form of a transformation of data, but no information need be provided about how to perform the calculation. By declaring a concept, you are instructing the BRAIN server that this is a node in the basic recurrent artificial intelligence network that must be learned. Consequently, concept nodes must have corresponding curricula to teach them.</p>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">concept</span> <span class="nx">AbstractConceptName</span>
  <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="nx">ConceptSchema</span>
  <span class="k">follows</span> <span class="nx">Antecedent1</span><span class="p">,</span> <span class="nx">Antecedent2</span>   
  <span class="k">feeds</span> <span class="nx">Dependent1</span>                 
<span class="k">end</span>
</code></pre>
<p>Because concepts are learned, their declarations tend to be fairly simple.
Inkling will support the ability to explicitly tell the BRAIN server what learning algorithms and
architecture to use but this is not yet implemented. (It is an unusual case).  </p>

<p>The typical components of a concept statement are shown in the accompanying
panel. </p>

<blockquote>
<p>Concept Syntax</p>
</blockquote>
<pre class="highlight inkling tab-inkling--syntax"><code><span class="nx">conceptStatement</span> <span class="p">:</span><span class="o">=</span>
<span class="k">concept</span>
  <span class="k">is</span> <span class="p">[</span> <span class="nx">classifier</span> <span class="o">|</span> <span class="nx">estimator</span> <span class="p">]</span>
  <span class="k">predicts</span> <span class="p">(</span> <span class="nx">schemaRef</span> <span class="p">)</span>
  <span class="p">[</span>
    <span class="k">follows</span>
      <span class="nx">inputSource</span> <span class="p">[','</span> <span class="nx">inputSource</span> <span class="p">]</span><span class="o">*</span>
    <span class="p">]?</span>
  <span class="p">[</span>
    <span class="k">feeds</span>
      <span class="nx">outputTarget</span> <span class="p">[','</span> <span class="nx">outputTarget</span> <span class="p">]</span><span class="o">*</span>

  <span class="p">]?</span>
<span class="k">end</span>

<span class="nx">inputSource</span> <span class="p">::</span><span class="o">=</span>
    <span class="kr">input</span> <span class="p">'('</span> <span class="nx">schemaRef</span><span class="p">?</span> <span class="p">')'</span> <span class="o">|</span> <span class="o">&lt;</span><span class="nx">name</span><span class="o">&gt;</span>     <span class="c1"># name of a concept or input</span>

<span class="nx">outputTarget</span> <span class="p">::</span><span class="o">=</span>
    <span class="kr">output</span> <span class="o">|</span>  <span class="o">&lt;</span><span class="nx">name</span><span class="o">&gt;</span>                      <span class="c1"># name of a concept or output</span>
</code></pre>
<p>The <code class="prettyprint">is</code> keyword specifies the overall class of concept that is being modeled.
For example, a classifier will learn to identify a label corresponding to its
input, an estimator will learn to predict a value, and a predictor (not yet
implemented) will learn sequences and predict subsequent items in a sequence.</p>

<p>The <code class="prettyprint">predicts</code> keyword declares the concept&rsquo;s output.</p>

<p>The <code class="prettyprint">follows</code> and <code class="prettyprint">feeds</code> keywords establish connectivity in the BRAIN directed graph. </p>

<p>The <code class="prettyprint">follows</code>, <code class="prettyprint">feeds</code>, and <code class="prettyprint">predicts</code> clauses can be in any order. </p>

<p>Like all Inkling toplevel statements, the <code class="prettyprint">end</code> keyword declares the end of the
statement. </p>

<h3 id="usage">Usage</h3>

<p>The concept statement specifies input sources and output targets. Input sources
are listed after the <code class="prettyprint">follows</code> keyword and output sources are listed after the
<code class="prettyprint">feeds</code> keyword. </p>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">concept</span> <span class="nx">bar</span> <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="p">(</span><span class="nx">Move</span><span class="p">)</span>
  <span class="c1"># feeds foo            not necessary </span>
  <span class="k">follows</span> <span class="kr">input</span><span class="p">(</span><span class="kr">UInt8</span> <span class="nx">x</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">concept</span> <span class="nx">foo</span> <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="p">(</span><span class="nx">Action</span><span class="p">)</span>
  <span class="k">follows</span> <span class="nx">bar</span>     
  <span class="k">feeds</span> <span class="kr">output</span>
<span class="k">end</span>
</code></pre>
<p>Note that <code class="prettyprint">follows</code> and <code class="prettyprint">feeds</code> can be redundant. If our concept foo <code class="prettyprint">follows</code>
our concept bar then we know that bar is an input source for foo, and it isn&rsquo;t 
necessary to also specify that concept bar <code class="prettyprint">feeds</code> concept foo.  Specifying foo 
<code class="prettyprint">follows</code> bar is enough. However, specifying both (foo <code class="prettyprint">follows</code> bar and bar <code class="prettyprint">feeds</code> foo) is valid. </p>

<p>Input sources can be other concepts or the <code class="prettyprint">input</code> stream.  The <code class="prettyprint">input</code> stream
is the original input to the system. It flows into the system from outside the
BRAIN. Each reference to the <code class="prettyprint">input</code> stream must have a schema, which can be an
<a href="#anonymous-schema">anonymous schema</a>.</p>

<p>Output targets can also be other concepts or the <code class="prettyprint">output</code> stream. The <code class="prettyprint">output</code> stream refers to the output of the BRAIN. 
The <code class="prettyprint">output</code> stream is never referenced with a schema.</p>

<p>The concept output is described in the <code class="prettyprint">predicts</code> clause. The schema reference after the
<code class="prettyprint">predicts</code> keyword describes the data produced by the trained concept.  (This
schema reference is required but it can be <a href="#anonymous-schema">anonymous</a>.)
For example, if this concept classifies email into spam and not spam, the output schema for the concept would be a Bool. </p>

<p>The <code class="prettyprint">is</code> clause characterizes the output. The <code class="prettyprint">is classifier</code> form specifies that the output is an enum. 
The <code class="prettyprint">is estimator</code> form specifies that the output is a value.</p>

<p>Concept input can come from a concept as well as the <code class="prettyprint">input</code> stream.</p>

<p>When input comes from a concept, the type of the input doesn&rsquo;t matter. This is because concepts don’t act on normal data science data structures. The concept input is a matrix which has no type. </p>

<p>Concepts do care about their input types when input comes from a stream. This is because the input needs to go through an encoder to become a tensor and the encoder must know the input types. In this case the input types are defined by the output schema of the stream feeding the concept. </p>

<p>The <code class="prettyprint">predicts</code> output of a concept is also a matrix which has no type (a
tensor). The <code class="prettyprint">predicts</code> output schema represents the typed output of the decoder for that output matrix. </p>

<h3 id="examples">Examples</h3>

<p>We show Inkling for the concepts get_high_score, Digit, Curvature, and Segments. </p>

<p><strong>get_high_score</strong></p>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">concept</span> <span class="nx">get_high_score</span>
  <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="nx">PlayerMove</span>
  <span class="k">follows</span> <span class="kr">input</span><span class="p">(</span><span class="nx">GameState</span><span class="p">)</span>
  <span class="k">feeds</span> <span class="kr">output</span>
<span class="k">end</span>
</code></pre>
<ul>
<li><code class="prettyprint">conceptName</code>: get_high_score</li>
<li><code class="prettyprint">is</code>: classifier</li>
<li><code class="prettyprint">predicts</code>: PlayerMove</li>
<li><code class="prettyprint">input(schemaName)</code>: input(GameState)</li>
<li><code class="prettyprint">feeds</code>: output</li>
</ul>

<p><strong>Digit</strong></p>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">concept</span> <span class="nx">Digit</span>
  <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="nx">MNIST_output</span>
  <span class="k">follows</span> <span class="nx">Curvature</span><span class="p">,</span> <span class="nx">Segments</span><span class="p">,</span> <span class="kr">input</span><span class="p">(</span><span class="nx">MNIST_input</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<ul>
<li><code class="prettyprint">conceptName</code>: Digit</li>
<li><code class="prettyprint">is</code>: classifier</li>
<li><code class="prettyprint">predicts</code>: MNIST_output</li>
<li><code class="prettyprint">follows</code>: Curvature and Segments are concepts and <code class="prettyprint">input(MNIST_input)</code> is
the <code class="prettyprint">input</code> stream with the MNIST_input schema</li>
</ul>

<p><strong>Curvature</strong></p>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">concept</span> <span class="nx">Curvature</span>
  <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="p">(</span><span class="nx">curve_output</span><span class="p">)</span>
  <span class="k">follows</span> <span class="kr">input</span><span class="p">(</span><span class="nx">MNIST_input</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<ul>
<li><code class="prettyprint">conceptName</code>: Curvature</li>
<li><code class="prettyprint">is</code>: classifier</li>
<li><code class="prettyprint">predicts</code>: curve_output</li>
<li><code class="prettyprint">follows</code>: <code class="prettyprint">input(MNIST_input)</code></li>
</ul>

<p>Note that Digit specifies Curvature in its <code class="prettyprint">follows</code> clause. That means logically
that Curvature <code class="prettyprint">feeds</code> Digit. But specifying this relationship in one place is
enough. There would be nothing wrong with adding a <code class="prettyprint">feeds</code> Digit clause to
Curvature but it isn&rsquo;t required. </p>

<p><strong>Segments</strong></p>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">concept</span> <span class="nx">Segments</span>
  <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="p">(</span><span class="nx">segments_output</span><span class="p">)</span>
  <span class="k">follows</span> <span class="kr">input</span><span class="p">(</span><span class="nx">MNIST_input</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<ul>
<li><code class="prettyprint">conceptName</code>: Segments</li>
<li><code class="prettyprint">is</code>: classifier</li>
<li><code class="prettyprint">predicts</code>: segments_output</li>
<li><code class="prettyprint">follows</code>: <code class="prettyprint">input(MNIST_input)</code></li>
</ul>

          <h1 id="curriculums">Curriculums</h1>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">curriculum</span> <span class="nx">MyCurriculum</span>
  <span class="k">train</span> <span class="nx">MyConcept</span>
  <span class="k">with</span> <span class="k">simulator</span> <span class="nx">MySimulator</span>
  <span class="k">objective</span> <span class="nx">MyObjective</span>
    <span class="c1"># lessons are specified here.</span>
<span class="k">end</span>
</code></pre>
<p>The <code class="prettyprint">curriculum</code> statement is used to specify the training of Inkling concepts. </p>

<p>The curriculum specifies the <a href="#concepts">concept</a> which is being taught. 
The <a href="#lessons">lessons</a> defined within the curriculum are used to train that concept.</p>

<blockquote>
<p>Curriculum Syntax</p>
</blockquote>
<pre class="highlight inkling tab-inkling--syntax"><code><span class="k">curriculum</span> <span class="o">&lt;</span><span class="nx">name</span><span class="o">&gt;</span>                            
<span class="k">train</span>  <span class="o">&lt;</span><span class="nx">conceptName</span><span class="o">&gt;</span>                        
<span class="p">[</span> 
  <span class="k">with</span> <span class="k">simulator</span> <span class="o">&lt;</span><span class="nx">simulatorName</span><span class="o">&gt;</span>  
  <span class="k">objective</span> <span class="o">&lt;</span><span class="nx">objectiveFunctionName</span><span class="o">&gt;</span> 
<span class="p">]</span><span class="o">+</span> 
<span class="p">[</span>
  <span class="k">using</span> <span class="o">&lt;</span><span class="nx">simulatorName</span><span class="o">&gt;</span>         <span class="c1"># using clause</span>
  <span class="p">[</span>
    <span class="nx">lessonClause</span>                <span class="c1"># lesson set for this simulator</span>
  <span class="p">]</span><span class="o">+</span>
  <span class="k">end</span>
<span class="p">]</span><span class="o">+</span>
<span class="k">end</span>
</code></pre>
<h3 id="usage">Usage</h3>

<p>There can be only one curriculum per concept.</p>

<p>Every concept must have a curriculum.</p>

<p>Every simulator must be declared with a simulator clause.</p>

<p>The <code class="prettyprint">train</code> keyword indicates which concept this curriculum trains.</p>

<p>The <code class="prettyprint">objective</code> keyword specifies the objective function.  This function
specifies the termination condition for training. It is always required. </p>

<p>If the curriculum uses one simulator, the <code class="prettyprint">using simulator</code> clause is optional. 
Currently, only one simulator per curriculum is supported, but support for 
multiple simulators per curriculum is anticipated. In that case, for more
than one simulator, the <code class="prettyprint">using simulator</code> clause is required, to associate a lesson set
with a specified simulator. When there are multiple simulators per curriculum, 
there must be one <code class="prettyprint">using simulator</code> 
clause for every simulator specified in the <code class="prettyprint">with simulator</code> clause. </p>

<h3 id="discussion">Discussion</h3>

<p>The concept graph is laid out by the <a href="../guides/ai-engine-guide.html#architect">architect</a> and then handed to the
<a href="../guides/ai-engine-guide.html#instructor">instructor</a>. The instructor will look for the starting point among the concepts and
their corresponding curriculums, and then will use the curriculum to train
the concept.</p>

<p>A curriculum (and its concept) is associated with a simulator and that
simulator has an objective function and a schema. The instructor trains each
concept using a simulator with the specified objective function. (Support for 
multiple simulators per curriculum is anticipated.) </p>

<p>The lesson clause configures the lesson and describes training and the
objective. For more information see the section on <a href="#lessons">lessons</a>.</p>

<h3 id="breakout-example">Breakout Example</h3>

<blockquote>
<p>Breakout Example</p>
</blockquote>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">simulator</span> <span class="nx">breakout_simulator</span><span class="p">(</span><span class="nx">BreakoutConfig</span><span class="p">)</span> 
  <span class="k">action</span>  <span class="p">(</span><span class="nx">PlayerMove</span><span class="p">)</span>
  <span class="k">state</span>  <span class="p">(</span><span class="nx">GameState</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<p>The <code class="prettyprint">simulator</code> clause declares the simulator name and several schemas. The first
schema specifies the schema for configuration of the simulator and it appears in
parentheses immediately after the simulator name. In this instance, the
configuration schema is named <code class="prettyprint">BreakoutConfig</code>. In the example, the configure
clauses of the lessons initializes the configuration schema fields of <code class="prettyprint">BreakoutConfig</code>.</p>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">schema</span> <span class="nx">BreakoutConfig</span>
    <span class="kr">UInt16</span> <span class="nx">level</span><span class="p">,</span>
    <span class="kr">UInt8</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">}</span> <span class="nx">paddle_width</span><span class="p">,</span>
    <span class="kr">Float32</span> <span class="nx">bricks_percent</span>
<span class="k">end</span>

<span class="k">schema</span> <span class="nx">GameState</span>                <span class="c1"># state schema</span>
    <span class="kr">Luminance</span><span class="p">(</span><span class="mi">84</span><span class="p">,</span> <span class="mi">336</span><span class="p">)</span> <span class="nx">pixels</span>
<span class="k">end</span>

<span class="k">curriculum</span> <span class="nx">high_score_curriculum</span>
  <span class="k">train</span> <span class="nx">high_score</span>
  <span class="k">with</span> <span class="k">simulator</span> <span class="nx">breakout_simulator</span>
  <span class="k">objective</span> <span class="nx">score</span>
    <span class="k">lesson</span> <span class="nx">score_lesson</span>
      <span class="k">configure</span>
        <span class="k">constrain</span> <span class="nx">bricks_percent</span> <span class="k">with</span> <span class="kr">Float32</span><span class="p">{</span><span class="mf">1.0</span><span class="p">},</span>
        <span class="k">constrain</span> <span class="nx">level</span> <span class="k">with</span> <span class="kr">UInt16</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">100</span><span class="p">},</span>
        <span class="k">constrain</span> <span class="nx">paddle_width</span> <span class="k">with</span> <span class="kr">UInt8</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">}</span>
      <span class="k">until</span>
        <span class="k">maximize</span> <span class="nx">score</span>
<span class="k">end</span>
</code></pre>
<p>The names in the configuration schema <code class="prettyprint">BreakoutConfig</code> are the names referenced in the configure
clause of the lessons. When a lesson is initiated, the configuration data as described 
in the configuration schema is sent
to the simulator. The configuration data will be generated according to the
range expression in the lesson configure clause for a field. </p>

<p>The second schema specified in the simulator clause is the <code class="prettyprint">state</code> schema. It is
specified after the <code class="prettyprint">state</code> keyword in the simulator clause. This is the schema
that defines what is sent to the lesson. Recall that a simulator has state. That
means that input to the lesson will consist of the state of the game as a result
of the previous lesson execution. For Breakout this schema is called
<code class="prettyprint">GameState</code>. The <code class="prettyprint">Luminance</code> field in <code class="prettyprint">GameState</code> describes the state of play in
pixels. </p>

<p>The simulator <code class="prettyprint">state</code> schema
must match the schema associated with <code class="prettyprint">input</code> for the system.
This reflects the fact that the state is the input to the simulator for 
selection of the next move.</p>
<pre class="highlight inkling tab-inkling--code"><code><span class="c1"># predict schema for high_score and action schema for simulator</span>
<span class="k">schema</span> <span class="nx">PlayerMove</span>               <span class="c1"># action schema</span>
    <span class="kr">Int8</span><span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span> <span class="nx">move</span>         <span class="c1"># possible game moves</span>
<span class="k">end</span>

<span class="k">concept</span> <span class="nx">high_score</span> <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="p">(</span><span class="nx">PlayerMove</span><span class="p">)</span>
  <span class="k">follows</span> <span class="nx">keep_paddle_under_ball</span><span class="p">,</span> <span class="kr">input</span><span class="p">(</span><span class="nx">GameState</span><span class="p">)</span>
  <span class="k">feeds</span> <span class="kr">output</span>
<span class="k">end</span>
</code></pre>
<p>The <code class="prettyprint">action</code> schema (which is <code class="prettyprint">PlayerMove</code>) is the third schema specified in the simulator clause.
The simulator <code class="prettyprint">action</code> schema must match the <code class="prettyprint">predicts</code> schema of the concept being trained.
In our example the concept <code class="prettyprint">high_score</code> trains the BRAIN to select the next move, which will have
one of the values specified in the <code class="prettyprint">PlayerMove</code> schema range expression. </p>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">concept</span> <span class="nx">keep_paddle_under_ball</span> <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="p">(</span><span class="nx">PlayerMove</span><span class="p">)</span>
  <span class="k">follows</span> <span class="kr">input</span><span class="p">(</span><span class="nx">GameState</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">curriculum</span> <span class="nx">keep_paddle_under_ball_curriculum</span>
  <span class="k">train</span> <span class="nx">keep_paddle_under_ball</span>
  <span class="k">with</span> <span class="k">simulator</span> <span class="nx">breakout_simulator</span>
  <span class="k">objective</span> <span class="nx">ball_paddle_distance</span>
    <span class="k">lesson</span> <span class="nx">track_ball_any_paddle</span>
      <span class="k">configure</span>
        <span class="k">constrain</span> <span class="nx">bricks_percent</span> <span class="k">with</span> <span class="kr">Float32</span><span class="p">{</span><span class="mf">1.0</span><span class="p">},</span>
        <span class="k">constrain</span> <span class="nx">level</span> <span class="k">with</span> <span class="kr">UInt16</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">100</span><span class="p">},</span>
        <span class="k">constrain</span> <span class="nx">paddle_width</span> <span class="k">with</span> <span class="kr">UInt8</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">}</span>
      <span class="k">until</span>
        <span class="k">maximize</span> <span class="nx">ball_paddle_closeness</span>
    <span class="k">lesson</span> <span class="nx">track_ball_wide_paddle</span>
      <span class="k">configure</span>
        <span class="k">constrain</span> <span class="nx">bricks_percent</span> <span class="k">with</span> <span class="kr">Float32</span><span class="p">{</span><span class="mf">1.0</span><span class="p">},</span>
        <span class="k">constrain</span> <span class="nx">level</span> <span class="k">with</span> <span class="kr">UInt16</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">100</span><span class="p">},</span>
        <span class="k">constrain</span> <span class="nx">paddle_width</span> <span class="k">with</span> <span class="kr">UInt8</span><span class="p">{</span><span class="mi">4</span><span class="p">}</span>
      <span class="k">until</span>
        <span class="k">maximize</span> <span class="nx">ball_paddle_closeness</span>
<span class="k">end</span>
</code></pre>
<p>One other concept which helps with playing Breakout is <code class="prettyprint">keep_paddle_under_ball</code>.
In the curriculum for this concept, there are two lessons. One of the lessons,
<code class="prettyprint">track_ball_any_paddle</code>, uses a <a href="#constrained-types-and-range-expressions">range expression</a> to vary paddle width from 1 to 4. The other lesson, 
<code class="prettyprint">track_ball_wide_paddle</code>, has a fixed paddle width of 4. In training this
concept, the fixed wide width paddle lesson is easier to train, and that one
would be trained first, resulting in faster and more effective training time
overall.  </p>

          <h1 id="lessons">Lessons</h1>

<p>Lesson syntax and semantics can vary slightly depending on the <a href="#curriculums">curriculum</a> training type. 
A curriculum specifies its training type by specifying that it trains with a
<a href="#simulators">simulator</a>, with data, or with a generator. </p>

<aside class="notice">
Future support is expected for training with generators and with data, and those training types will be documented when the features are supported. 
</aside>

<blockquote>
<p>Lesson Syntax</p>
</blockquote>
<pre class="highlight inkling tab-inkling--syntax"><code><span class="nx">lessonStatement</span> <span class="p">::</span><span class="o">=</span>
  <span class="k">lesson</span> <span class="o">&lt;</span><span class="nx">lessonName</span><span class="o">&gt;</span>
    <span class="nx">followsClause</span><span class="p">?</span>
    <span class="nx">configureClause</span>
    <span class="nx">trainClause</span><span class="p">?</span>
    <span class="nx">testClause</span><span class="p">?</span>
    <span class="nx">untilClause</span>
</code></pre>
<p>The <code class="prettyprint">lesson</code> declares an individual lesson for the concept being trained by the curriculum.  Lessons are contained within curriculum statements. A curriculum can contain multiple lessons.</p>

<p>Lessons provide control over the training of the mental model. They allow 
the training of the concept to be broken down into phases where each phase is implemented by a lesson.
Lessons allow the machine to learn the concept in stages rather than all at once. </p>

<h3 id="usage">Usage</h3>

<p>The <code class="prettyprint">configure</code> and the <code class="prettyprint">until</code> clauses are required. </p>

<p>The <code class="prettyprint">train</code> and <code class="prettyprint">test</code> clauses are optional.</p>

<p>Lessons can be ordered, using the <code class="prettyprint">follows</code> clause. Note that this ordering is a suggestion to the instructor, not a hard and fast rule.  If there is no <code class="prettyprint">follows</code> clause and the lessons are executed in parallel, training will be slower.</p>

<h3 id="example">Example</h3>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">simulator</span> <span class="nx">breakout_simulator</span><span class="p">(</span><span class="nx">BreakoutConfig</span><span class="p">)</span>
  <span class="k">action</span>  <span class="p">(</span><span class="nx">PlayerMove</span><span class="p">)</span>
  <span class="k">state</span> <span class="p">(</span><span class="nx">GameState</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">schema</span> <span class="nx">GameState</span>
  <span class="kr">Luminance</span><span class="p">(</span><span class="mi">84</span><span class="p">,</span> <span class="mi">336</span><span class="p">)</span> <span class="nx">pixels</span>
<span class="k">end</span>

<span class="k">schema</span> <span class="nx">PlayerMove</span>
  <span class="kr">Int8</span><span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span> <span class="nx">move</span>
<span class="k">end</span>

<span class="k">schema</span> <span class="nx">BreakoutConfig</span> <span class="c1"># configured in lesson configureClause</span>
  <span class="kr">Int32</span> <span class="nx">level</span><span class="p">,</span>
  <span class="kr">Int8</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">}</span> <span class="nx">paddle_width</span><span class="p">,</span>
  <span class="kr">Float32</span> <span class="nx">bricks_percent</span>
<span class="k">end</span>

<span class="k">concept</span> <span class="nx">high_score</span> <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="p">(</span><span class="nx">PlayerMove</span><span class="p">)</span>
  <span class="k">follows</span> <span class="nx">keep_paddle_under_ball</span><span class="p">,</span> <span class="kr">input</span><span class="p">(</span><span class="nx">GameState</span><span class="p">)</span>
  <span class="k">feeds</span> <span class="kr">output</span>
<span class="k">end</span>

<span class="k">curriculum</span> <span class="nx">ball_location_curriculum</span>
  <span class="k">train</span> <span class="nx">ball_location</span>
  <span class="k">with</span> <span class="k">simulator</span> <span class="nx">breakout_simulator</span>
  <span class="k">objective</span> <span class="nx">ball_location_distance</span>

    <span class="k">lesson</span> <span class="nx">constant_breakout</span>
      <span class="k">configure</span>           <span class="c1"># configure to constant values</span>
        <span class="k">constrain</span> <span class="nx">bricks_percent</span> <span class="k">with</span> <span class="kr">Float32</span><span class="p">{</span><span class="mf">0.5</span><span class="p">},</span>
        <span class="k">constrain</span> <span class="nx">level</span> <span class="k">with</span> <span class="kr">Int32</span><span class="p">{</span><span class="mi">1</span><span class="p">},</span>    <span class="c1"># e.g. level = 1</span>
        <span class="k">constrain</span> <span class="nx">paddle_width</span> <span class="k">with</span> <span class="kr">Int8</span><span class="p">{</span><span class="mi">4</span><span class="p">}</span>
      <span class="k">train</span>
        <span class="k">from</span> <span class="nx">frame</span> <span class="k">in</span> <span class="nx">breakout_simulator</span>
        <span class="k">select</span> <span class="nx">frame</span>
        <span class="k">send</span> <span class="nx">frame</span>
      <span class="k">test</span>
        <span class="k">from</span> <span class="nx">frame</span> <span class="k">in</span> <span class="nx">breakout_simulator</span>
        <span class="k">select</span> <span class="nx">frame</span>
        <span class="k">send</span> <span class="nx">frame</span>
      <span class="k">until</span>
        <span class="k">minimize</span> <span class="nx">ball_location_distance</span>

    <span class="k">lesson</span> <span class="nx">vary_breakout</span> <span class="k">follows</span> <span class="nx">constant_breakout</span>
      <span class="k">configure</span>          <span class="c1"># configure to type constraints</span>
      <span class="k">constrain</span> <span class="nx">bricks_percent</span> <span class="k">with</span> <span class="kr">Float32</span><span class="p">{</span><span class="mf">0.1</span><span class="p">:</span><span class="mf">0.01</span><span class="p">:</span><span class="mf">1.0</span><span class="p">},</span>
      <span class="k">constrain</span> <span class="nx">level</span> <span class="k">with</span> <span class="kr">Int32</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">100</span><span class="p">},</span> <span class="c1"># e.g. level varies from 1..100</span>
      <span class="k">constrain</span> <span class="nx">paddle_width</span> <span class="k">with</span> <span class="kr">Int8</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">}</span>
    <span class="k">train</span>
      <span class="k">from</span> <span class="nx">frame</span> <span class="k">in</span> <span class="nx">breakout_simulator</span>
      <span class="k">select</span> <span class="nx">frame</span>
      <span class="k">send</span> <span class="nx">frame</span>
    <span class="k">test</span>
      <span class="k">from</span> <span class="nx">frame</span> <span class="k">in</span> <span class="nx">breakout_simulator</span>
      <span class="k">select</span> <span class="nx">frame</span>
      <span class="k">send</span> <span class="nx">frame</span>
    <span class="k">until</span>
      <span class="k">minimize</span> <span class="nx">ball_location_distance</span>
<span class="k">end</span>
</code></pre>
<p>In this example we show lessons that break into stages the task of playing
the game breakout. </p>

<ul>
<li>The first lesson, <code class="prettyprint">constant_breakout</code>, trains the machine
with a set of fixed values as configuration parameters. </li>
<li>The second lesson,
<code class="prettyprint">vary_breakout</code>, which follows <code class="prettyprint">constant_breakout</code>, trains the machine with a set of configuration parameters that vary according to specified type constraints.</li>
</ul>

<p>The two lessons in our example, <code class="prettyprint">constant_breakout</code> and <code class="prettyprint">vary_breakout</code>, are different in their configure clause. The first sets the fields in the configuration schema to constant values and the second lesson, <code class="prettyprint">vary_breakout</code>, generates sets of values constrained by the type constraint. </p>

<p>Note that the identifiers specified after the <code class="prettyprint">constrain</code> keyword in our example
specify fields in the
configuration schema for the simulator. These fields are <code class="prettyprint">bricks_percent</code>,
<code class="prettyprint">level</code>, and <code class="prettyprint">paddle_width</code>. When such fields are initialized with values from a
type constraint they are called <em>placeholders</em>.  This means that the name is is not the name of a specific value but rather it is the name of a range of values which will be input during training.</p>

<p>Schema declarations can also use type constraints. They are discussed in depth
<a href="#constrained-types-and-range-expressions">here</a>.</p>

<h2 id="lesson-subclauses">Lesson Subclauses</h2>

<p>In this section we discuss the <code class="prettyprint">follows</code> clause, the <code class="prettyprint">configure</code> clause, the
<code class="prettyprint">test</code> and <code class="prettyprint">train</code> clause, and the <code class="prettyprint">until</code> clause.</p>

<ul>
<li><p>Lessons can be ordered, using the <code class="prettyprint">follows</code> clause. This will specify the order of lessons in training and can be more efficient.</p></li>
<li><p>Lessons are configured, using the <code class="prettyprint">configure</code> clause. This configures data for the lesson. </p></li>
<li><p>The <code class="prettyprint">test</code> and <code class="prettyprint">train</code> clauses describe testing and training, and are optional. 
Note that whereas the <code class="prettyprint">test</code> clause is optional for any particular lesson, if
the last lesson has no <code class="prettyprint">test</code> clause it is an error.</p></li>
<li><p>The <code class="prettyprint">until</code> clause describes success for the objective function. </p></li>
</ul>

<h6 id="follows-clause">Follows Clause</h6>

<blockquote>
<p>Follows Clause Syntax</p>
</blockquote>
<pre class="highlight inkling tab-inkling--syntax"><code><span class="k">lesson</span> <span class="o">&lt;</span><span class="nx">lessonName</span><span class="o">&gt;</span>
   <span class="nx">followsClause</span><span class="p">?</span>

<span class="nx">followsClause</span> <span class="p">::</span><span class="o">=</span>
<span class="k">follows</span> 
    <span class="nx">lessonName</span> <span class="p">[</span> <span class="p">','</span> <span class="nx">lessonName</span><span class="p">]</span><span class="o">*</span> 
</code></pre>
<p>The <code class="prettyprint">follows</code> clause 
can be used to order lessons. Note that this ordering is a suggestion to the instructor, not a hard and fast rule.  If there is no <code class="prettyprint">follows</code> clause and the lessons are executed in parallel, training will be slower.</p>

<h3 id="usage">Usage</h3>

<p>The <code class="prettyprint">follows</code> clause is optional.</p>

<h6 id="configure-clause">Configure Clause</h6>

<blockquote>
<p>Configure Clause Syntax</p>
</blockquote>
<pre class="highlight inkling tab-inkling--syntax"><code><span class="nx">configureClause</span> <span class="p">::</span><span class="o">=</span>
<span class="k">configure</span>
    <span class="p">[</span> <span class="nx">constrainClause</span> <span class="p">[</span> <span class="p">','</span> <span class="nx">constrainClause</span><span class="p">]</span><span class="o">*</span> <span class="p">]</span><span class="o">*</span>

<span class="nx">constrainClause</span> <span class="p">:</span><span class="o">=</span> 
<span class="k">constrain</span> <span class="o">&lt;</span><span class="nx">schemaFieldName</span><span class="o">&gt;</span> <span class="k">with</span>  

    <span class="p">(</span> <span class="nx">constrainedType</span> <span class="p">)</span>
</code></pre>
<p>The <code class="prettyprint">configure</code> clause function is to configure data for training and testing.
The <code class="prettyprint">configure</code> clause has <code class="prettyprint">constrain</code> subclauses that each specify a
placeholder for a field in the configuration schema. The placeholder specifies a
range of values for the field through <a href="#constrained-types-and-range-expressions">constrained types and range expressions</a>.</p>

<h3 id="usage">Usage</h3>

<p>A <code class="prettyprint">configure</code> clause is required.</p>

<h3 id="placeholder">Placeholder</h3>

<p>The constraints in the <code class="prettyprint">configure</code> clause configure the fields in the
configuration schema for the simulator. These fields are called placeholders. In the accompanying
example <code class="prettyprint">level</code> is a placeholder. It is also a field in the configuration schema. </p>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">constrain</span> <span class="nx">level</span> <span class="k">with</span> <span class="kr">Int32</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">}</span>   <span class="c1"># level is a placeholder name. </span>
</code></pre>
<p>A placeholder is not the name of a specific value but rather it is the name
associated with a set of possible values which will be input by the instructor
during training. The characteristics of this set are specified in the
constraint. In this case, the values will be integers between 1 and 10. Note
there is no assumption of order. The instructor will randomly choose members
from this set. </p>

<p>The type <code class="prettyprint">Int32 {1:10}</code> is called a <a href="#constrained-types-and-range-expressions">constrained type</a>. The syntax <code class="prettyprint">{1:10}</code> is
called a <a href="#constrained-types-and-range-expressions">range expression</a>.  These topics are discussed in depth in the Schema chapter. </p>

<p>The field definition of <code class="prettyprint">level</code> in schema <code class="prettyprint">BreakoutConfig</code> is <code class="prettyprint">Int32  level</code>.
In order to be a valid constraint, the placeholder definition for <code class="prettyprint">level</code> must
conform to the field definition. This means the types must be identical.
Also the range expression on the placeholder must specify a subset of the values on
the field definition. If there is no range expression on the field definition,
the maximum range of values for the type is assumed, so any valid range
expression on the placeholder would be valid.</p>

<h3 id="example">Example</h3>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">schema</span> <span class="nx">BreakoutConfig</span> 
  <span class="kr">Int32</span>  <span class="nx">level</span><span class="p">,</span>                     <span class="c1"># 'level', 'paddle_width', 'bricks_percent' </span>
  <span class="kr">Int8</span>   <span class="nx">paddle_width</span><span class="p">,</span>              <span class="c1"># are matched below in constrain clauses </span>
  <span class="kr">Float32</span> <span class="nx">bricks_percent</span> 
<span class="k">end</span>

<span class="k">curriculum</span> <span class="nx">keep_paddle_under_ball_curriculum</span> 
  <span class="k">train</span> <span class="nx">keep_paddle_under_ball</span> 
  <span class="k">with</span> <span class="k">simulator</span> <span class="nx">breakout_sim</span><span class="p">(</span><span class="nx">BreakoutConfig</span><span class="p">)</span> 
  <span class="k">objective</span> <span class="nx">ball_paddle_distance</span> 

    <span class="k">lesson</span> <span class="nx">track_ball</span> 
      <span class="k">configure</span> <span class="nx">breakout_sim</span> 
        <span class="k">constrain</span> <span class="nx">paddle_width</span>  <span class="k">with</span> <span class="kr">Int8</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">},</span>
        <span class="k">constrain</span> <span class="nx">level</span> <span class="k">with</span> <span class="kr">Int32</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">},</span> 
        <span class="k">constrain</span> <span class="nx">bricks_percent</span> <span class="k">with</span> <span class="kr">Float32</span><span class="p">{</span><span class="mf">0.1</span><span class="p">:</span><span class="mf">0.01</span><span class="p">:</span><span class="mf">1.0</span><span class="p">}</span>  
      <span class="k">until</span> 
        <span class="k">maximize</span> <span class="nx">ball_paddle_distance</span> 
<span class="k">end</span>
</code></pre>
<p>The accompanying example gives an overview of configuration using these Inkling code fragments in the context of a curriculum.  The simulator in the curriculum uses the <code class="prettyprint">BreakoutConfig</code> schema. Note how the field names and types in the simulator schema match up with the names and types of the placeholders in the constrain clauses. </p>

<p>In this example we show how configuration works for <code class="prettyprint">bricks_percent</code>.</p>

<p>The instructor selects values for <code class="prettyprint">bricks_percent</code> from the given range. <code class="prettyprint">Float32 {0.1:0.01:1.0}</code> is an Inkling specification for a constrained type. In a constrained type the values are all <code class="prettyprint">Float32</code> but they also obey the constraint specified.</p>

<p>We can also configure <code class="prettyprint">bricks_percent</code> to take a constant value:</p>

<p><code class="prettyprint">constrain bricks_percent with Float32 {1.0}</code></p>

<p><code class="prettyprint">Float32 {1.0}</code> is a Float32 constrained to take the value 1.0. This is the
value list form of the range expression. You can add values to the list as long as they are of the same type, so the following is also valid:</p>

<p><code class="prettyprint">constrain bricks_percent with Float32 {1.0, 1.5}</code></p>

<h6 id="train-and-test-clause">Train and Test Clause</h6>

<blockquote>
<p>Train and Test Clause Syntax</p>
</blockquote>
<pre class="highlight inkling tab-inkling--syntax"><code><span class="nx">trainClause</span> <span class="p">::</span><span class="o">=</span>
<span class="k">train</span>
  <span class="k">from</span> <span class="o">&lt;</span><span class="nx">item_name</span><span class="o">&gt;</span> <span class="k">in</span> <span class="o">&lt;</span><span class="nx">simulator_name</span><span class="o">&gt;</span>
  <span class="k">select</span> <span class="o">&lt;</span><span class="nx">item_name</span><span class="o">&gt;</span>
  <span class="k">send</span> <span class="o">&lt;</span><span class="nx">item_name</span><span class="o">&gt;</span>

<span class="nx">testClause</span> <span class="p">::</span><span class="o">=</span>
<span class="k">test</span>
  <span class="k">from</span> <span class="o">&lt;</span><span class="nx">item_name</span><span class="o">&gt;</span> <span class="k">in</span> <span class="o">&lt;</span><span class="nx">simulator_name</span><span class="o">&gt;</span>
  <span class="k">select</span> <span class="o">&lt;</span><span class="nx">item_name</span><span class="o">&gt;</span>
  <span class="k">send</span> <span class="o">&lt;</span><span class="nx">item_name</span><span class="o">&gt;</span>
</code></pre>
<p>The <code class="prettyprint">test</code> and <code class="prettyprint">train</code> clauses describe testing and training.</p>

<p>The <code class="prettyprint">from</code> subclause in the test/train syntax is used to name, describe, and select the
training data that is sent by the simulator to the lesson.</p>

<p>The <code class="prettyprint">test</code> clause and the <code class="prettyprint">train</code> clause have identical syntax except for
their keyword (<code class="prettyprint">train</code> or <code class="prettyprint">test</code>).  </p>

<h3 id="usage">Usage</h3>

<p>The <code class="prettyprint">test</code> and <code class="prettyprint">train</code> clauses are optional. </p>

<p>If neither the <code class="prettyprint">test</code> or <code class="prettyprint">train</code> lesson clauses are present, defaults for both
clauses are generated. The default in both cases is:</p>

<p><code class="prettyprint">from item in &lt;simulator_name&gt; select item send item</code></p>

<p>(Here <code class="prettyprint">&lt;simulator_name&gt;</code> refers to the name of the simulator being used by the
lesson.)</p>

<p>If one of the <code class="prettyprint">train</code> and <code class="prettyprint">test</code> clauses is present, no defaults are generated.</p>

<p>If the <code class="prettyprint">train</code> clause is not present, the return schema of the simulator must exactly match the input schema to the network.</p>

<p>The <code class="prettyprint">test</code> clause is not required for any particular lesson. But if the final lesson does not have a <code class="prettyprint">test</code> clause that is an error.</p>

<h3 id="example">Example</h3>

<p>In this example we show <code class="prettyprint">train</code> and <code class="prettyprint">test</code> clauses. </p>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">curriculum</span> <span class="nx">high_score_curriculum</span>
  <span class="k">train</span> <span class="nx">high_score</span>
  <span class="k">with</span> <span class="k">simulator</span> <span class="nx">breakout_simulator</span>
  <span class="k">objective</span> <span class="nx">score</span>
    <span class="k">lesson</span> <span class="nx">score_lesson</span>
      <span class="k">configure</span>
        <span class="k">constrain</span> <span class="nx">bricks_percent</span> <span class="k">with</span> <span class="kr">Float32</span><span class="p">{</span><span class="mf">1.0</span><span class="p">},</span>
        <span class="k">constrain</span> <span class="nx">level</span> <span class="k">with</span> <span class="kr">Int32</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">100</span><span class="p">},</span>
        <span class="k">constrain</span> <span class="nx">paddle_width</span> <span class="k">with</span> <span class="kr">Int8</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">}</span>
      <span class="k">train</span>
        <span class="k">from</span> <span class="nx">frame</span> <span class="k">in</span> <span class="nx">breakout_simulator</span>
        <span class="k">select</span> <span class="nx">frame</span>
        <span class="k">send</span> <span class="nx">frame</span>
      <span class="k">test</span>
        <span class="k">from</span> <span class="nx">frame</span> <span class="k">in</span> <span class="nx">breakout_simulator</span>
        <span class="k">select</span> <span class="nx">frame</span>
        <span class="k">send</span> <span class="nx">frame</span>
      <span class="k">until</span>
        <span class="k">maximize</span> <span class="nx">score</span>
<span class="k">end</span>

</code></pre>
<p>What is sent (via <code class="prettyprint">send</code>) to the neural network as a result of the <code class="prettyprint">train</code> must have the same schema as the system&rsquo;s input schema. In this case that is <code class="prettyprint">GameState</code>.  Note that <code class="prettyprint">GameState</code> is declared as the output schema of the simulator.</p>

<p>The data that comes out of the lesson will always flow into the input keyword.
The system is calculating a subgraph between the input and the concept being
trained and that portion of the mental model is involved in the training.</p>

<p>The curriculum represents a collection of lessons which collectively train a subgraph of the mental model. The lesson represents a phase in training a subgraph of the mental model. The lessons represent the phases of training.</p>

<p>All subgraphs begin with input and end with the concept under training and contain all nodes in between.</p>

<p>For training with a simulator, the trained statement equals the simulator output.</p>

<p>The trained statement can be understood as the input data to the trained network (or mental model).</p>

<p>The <code class="prettyprint">train</code> clause is optional. If it is not present a default is generated that
will send the simulator output (conforming to the simulator output schema) to the neural network. </p>

<h6 id="until-clause">Until Clause</h6>

<blockquote>
<p>Until Clause Syntax</p>
</blockquote>

<p>The <code class="prettyprint">until</code> clause in the lesson specifies the termination condition for training.</p>

<aside class="notice">
Currently, there may be issues with termination of lessons in series. If you intend to use multiple lessons in a curriculum please <a href="https://bons.ai/contact-us#contact-page-form">contact support</a> if you have issues with training.
</aside>
<pre class="highlight inkling tab-inkling--syntax"><code><span class="nx">untilClause</span> <span class="p">::</span><span class="o">=</span>
<span class="k">until</span>
      <span class="p">[</span> <span class="k">minimize</span> <span class="o">|</span> <span class="k">maximize</span> <span class="p">]</span> <span class="o">&lt;</span><span class="nx">objectiveFunctionName</span><span class="o">&gt;</span>
    <span class="o">|</span>
      <span class="o">&lt;</span><span class="nx">objectiveFunctionName</span><span class="o">&gt;</span> <span class="nx">relOp</span> <span class="nx">constantExpression</span>

<span class="nx">relOp</span> <span class="p">::</span><span class="o">=</span>
  <span class="p">'</span><span class="o">==</span><span class="p">'</span> <span class="o">|</span> <span class="p">'</span><span class="o">&lt;</span><span class="p">'</span> <span class="o">|</span> <span class="p">'</span><span class="o">&gt;</span><span class="p">'</span> <span class="o">|</span> <span class="p">'</span><span class="o">&lt;=</span><span class="p">'</span> <span class="o">|</span> <span class="p">'</span><span class="o">&gt;=</span><span class="p">'</span>
</code></pre>
<aside class="notice">
Future support of the `until` clause will include `minimize` and constant
expressions. Current support is limited to `maximize`.
</aside>

<h3 id="usage">Usage</h3>

<p>The <code class="prettyprint">until</code> clause is required.</p>

<h3 id="example">Example</h3>

<p>There are several examples of the <code class="prettyprint">until</code> clause above. They are excerpted in
the code panel.</p>
<pre class="highlight inkling tab-inkling--code"><code>      <span class="k">until</span> 
        <span class="k">maximize</span> <span class="nx">ball_paddle_distance</span> 
</code></pre><pre class="highlight inkling tab-inkling--code"><code>      <span class="k">until</span>
        <span class="k">maximize</span> <span class="nx">score</span>
</code></pre>
<p>These both specify that training should continue until the return value of the
objective function is maximized. </p>

          <h1 id="schemas">Schemas</h1>

<p>This is the reference for the keyword <code class="prettyprint">schema</code>. Also covered are the
definitions and uses of <a href="#types">Inkling types</a>, including <a href="#constrained-types-and-range-expressions">type constraints</a>.  These are used in schema declarations.</p>

<h2 id="schema-declarations">Schema Declarations</h2>
<pre class="highlight inkling tab-inkling--code"><code>   <span class="k">schema</span> <span class="nx">bar</span>       <span class="c1"># schema declaration</span>
      <span class="kr">Bool</span> <span class="nx">field1</span><span class="p">,</span>
      <span class="kr">Int8</span> <span class="nx">field2</span>
   <span class="k">end</span>
</code></pre>
<p>Schemas are declared with the <code class="prettyprint">schema</code> statement.</p>

<p>In Inkling a <code class="prettyprint">schema</code> describes a named record and its contained fields. Each field in a schema has a name and a type. A field may also have a type constraint that constrains the values that the datum described by this field will take.</p>
<pre class="highlight inkling tab-inkling--code"><code>   <span class="k">concept</span> <span class="nx">foo</span>
      <span class="k">is</span> <span class="nx">classifier</span>
      <span class="k">predicts</span> <span class="p">(</span><span class="nx">bar</span><span class="p">)</span> <span class="c1"># schema reference</span>
   <span class="k">end</span>
</code></pre>
<p>Statements (such as the <code class="prettyprint">concept</code> statement) can reference schemas by name.</p>
<pre class="highlight inkling tab-inkling--code"><code>   <span class="k">concept</span> <span class="nx">foo</span>
      <span class="k">is</span> <span class="nx">classifier</span>
      <span class="k">predicts</span> <span class="p">(</span><span class="kr">Bool</span> <span class="nx">field1</span><span class="p">,</span> <span class="kr">Int8</span> <span class="nx">field2</span><span class="p">)</span> <span class="c1"># anonymous schema</span>
   <span class="k">end</span>
</code></pre>
<p>Schemas can also be <a href="#anonymous-schema">anonymous</a>. In that case, instead of a schema name, a list of named fields is present.</p>

<p>Schemas describe the structure of data in Inkling streams, such as the
predefined <code class="prettyprint">input</code> and <code class="prettyprint">output</code> streams. In addition, many Inkling statements (for
example <code class="prettyprint">concept</code> and <code class="prettyprint">curriculum</code>) use schema references to describe the data that flows in and out of the construct.</p>

<blockquote>
<p>Schema Declaration Syntax</p>
</blockquote>
<pre class="highlight inkling tab-inkling--syntax"><code><span class="nx">schemaStmt</span> <span class="p">:</span><span class="o">=</span> 
<span class="k">schema</span> <span class="o">&lt;</span><span class="nx">name</span><span class="o">&gt;</span>                      
     <span class="nx">fieldDclnList</span> 
<span class="k">end</span>

<span class="nx">fieldDclnList</span>   <span class="p">:</span><span class="o">=</span>  <span class="nx">fieldDcln</span> <span class="p">[','</span> <span class="nx">fieldDcln</span>  <span class="p">]</span><span class="o">*</span>  

<span class="nx">fieldDcln</span>       <span class="p">:</span><span class="o">=</span>  <span class="nx">scalarDcln</span>   <span class="o">|</span> <span class="nx">structureDcln</span> 

<span class="nx">scalarDcln</span>      <span class="p">:</span><span class="o">=</span>  <span class="nx">primitiveType</span>   <span class="nx">rangeExpression</span><span class="p">?</span> <span class="o">&lt;</span><span class="nx">name</span><span class="o">&gt;</span>

<span class="nx">structureDcln</span>   <span class="p">:</span><span class="o">=</span>  <span class="nx">structure_type</span>   <span class="nx">structure_init</span> <span class="o">&lt;</span><span class="nx">name</span><span class="o">&gt;</span> 

<span class="nx">structure_type</span>  <span class="p">:</span><span class="o">=</span>  <span class="kr">Luminance</span> <span class="o">|</span> <span class="kr">Matrix</span> <span class="o">|</span> <span class="nx">Vector</span>

<span class="nx">structure_init</span>  <span class="p">:</span><span class="o">=</span>  <span class="p">'('</span> 
                        <span class="nx">luminance_init</span> <span class="o">|</span> <span class="nx">matrix_init</span> <span class="o">|</span> <span class="nx">vector_init</span>
                    <span class="p">')'</span>

<span class="nx">luminance_init</span>  <span class="p">:</span><span class="o">=</span>  <span class="nx">integerLiteral</span>  <span class="p">','</span> <span class="nx">integerLiteral</span> 

<span class="nx">matrix_init</span>     <span class="p">:</span><span class="o">=</span>  <span class="p">'('</span> <span class="nx">primitiveType</span> <span class="p">[</span> <span class="p">','</span> <span class="nx">primitivetype</span> <span class="p">]</span><span class="o">*</span> <span class="p">')'</span> 
                        <span class="p">','</span> <span class="nx">integerLiteral</span> <span class="p">[</span> <span class="p">','</span> <span class="nx">integerLiteral</span><span class="p">]</span><span class="o">*</span> 

<span class="nx">vector_init</span>     <span class="p">:</span><span class="o">=</span>  <span class="nx">primitiveType</span>   <span class="nx">rangeExpression</span><span class="p">?</span> <span class="p">','</span>  <span class="nx">integerLiteral</span> 
</code></pre>
<p>In the Schema Declaration Syntax, you will see references to Inkling primitive types and structured types
(Luminance, Matrix). These are discussed in in the <a href="#structured-types">Structured Types</a> section. </p>

<aside class="warning">
Due to limitations with Inkling’s communication with Tensorflow you can’t end your schema variables with an underscore and number such as `variable_1`, `variable_22`, etc.
</aside>

<h3 id="usage">Usage</h3>

<p>Schema fields must be separated from each other by commas. Schema declarations
are terminated by the <code class="prettyprint">end</code> keyword.</p>

<p>Field types can be any of the <a href="#primitive-types">Inkling primitive types</a> and <a href="#structured-types">Inkling structured types</a>. </p>

<p>In matrix initialization, a parenthesized list of types is followed by a list of dimensions. The number of types and the number of dimensions must match.</p>

<p>Matrix size must be an integral constant.  </p>

<aside class="warning">
Matrix and Vector are not yet implemented.
</aside>

<p>A schema field that has a primitive type can also have a type constraint that
constrains the set of potential values for that field. Examples and syntax of
type constraints are included in the <a href="#constrained-types-and-range-expressions">Constrained Types</a> section.</p>

<h3 id="discussion">Discussion</h3>

<p>Schemas tell the BRAIN system how to translate large matrices (tensors) to usable
values.</p>

<p>Note the inkling compiler does not do this translation, that is a runtime
transformation.  However the inkling compiler performs static checks
to verify that the schemas are valid in the context in which they are used. </p>
<pre class="highlight inkling tab-inkling--code"><code>  <span class="k">schema</span> <span class="nx">MNIST_schema</span>
    <span class="kr">Luminance</span><span class="p">(</span><span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span> <span class="nx">image</span> <span class="c1"># structured type</span>
  <span class="k">end</span>

  <span class="k">schema</span> <span class="nx">my_schema</span>
    <span class="kr">Int32</span> <span class="nx">x</span><span class="p">,</span>                <span class="c1"># primitive type</span>
    <span class="kr">Int32</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">}</span> <span class="nx">z</span>            <span class="c1"># primitive type with type constraint</span>
  <span class="k">end</span>
</code></pre>
<p>The code panel contains a few example schemas. 
The last field <code class="prettyprint">z</code> in <code class="prettyprint">my_schema</code> has constrained type <code class="prettyprint">Int32{1:5}</code>. For more information on this feature see <a href="#constrained-types-and-range-expressions">Constrained Types</a>.</p>

<h2 id="schema-references">Schema References</h2>
<pre class="highlight inkling tab-inkling--code"><code>   <span class="k">concept</span> <span class="nx">MyConcept</span>
      <span class="k">is</span> <span class="nx">classifier</span>
      <span class="k">predicts</span> <span class="p">(</span><span class="nx">MySchema</span><span class="p">)</span>       <span class="c1"># a schema reference</span>
   <span class="k">end</span>
</code></pre>
<p>Inkling statements can reference schemas by name. </p>

<h6 id="anonymous-schema">Anonymous Schema</h6>
<pre class="highlight inkling tab-inkling--code"><code>   <span class="k">concept</span> <span class="nx">MyConcept</span>
      <span class="k">is</span> <span class="nx">classifier</span>
      <span class="k">predicts</span> <span class="p">(</span><span class="kr">UInt8</span> <span class="nx">MyField</span><span class="p">)</span>  <span class="c1"># a anonymous schema </span>
   <span class="k">end</span>
</code></pre>
<p>Anywhere a schema name can
be referenced, a list of fields can appear. This is an <strong>anonymous schema</strong>. 
Anonymous schema can also be empty (that is, they can contain no
field definitions), if allowed in context.</p>

<blockquote>
<p>Schema Reference Syntax</p>
</blockquote>
<pre class="highlight inkling tab-inkling--syntax"><code><span class="nx">schemaRef</span> <span class="p">:</span><span class="o">=</span>                 
     <span class="p">'('</span>   <span class="p">')'</span>                  <span class="c1"># empty anonymous schema</span>
 <span class="o">|</span>   <span class="p">'('</span> <span class="o">&lt;</span><span class="nx">name</span><span class="o">&gt;</span> <span class="p">')'</span>             <span class="c1"># named schema</span>
 <span class="o">|</span>   <span class="p">'('</span>  <span class="o">&lt;</span><span class="nx">fieldDclnList</span><span class="o">&gt;</span> <span class="p">')</span>    <span class="c1"># non-empty anonymous schema</span>
</code></pre>
<h2 id="types">Types</h2>

<p>Inkling supports both primitive types and structured types.</p>

<h6 id="primitive-types">Primitive Types</h6>

<blockquote>
<p>Primitive Types List</p>
</blockquote>
<pre class="highlight inkling tab-inkling--syntax"><code><span class="nx">primitiveType</span> <span class="p">::</span><span class="o">=</span>
  <span class="kr">Double</span> <span class="o">|</span> <span class="kr">Float64</span> <span class="o">|</span> <span class="kr">Float32</span> <span class="o">|</span> <span class="kr">Int8</span> <span class="o">|</span> <span class="kr">Int16</span> <span class="o">|</span> <span class="kr">Int32</span> <span class="o">|</span>
  <span class="kr">Int64</span> <span class="o">|</span> <span class="kr">UInt8</span> <span class="o">|</span> <span class="kr">UInt16</span> <span class="o">|</span> <span class="kr">UInt32</span>  <span class="o">|</span> <span class="kr">UInt64</span> <span class="o">|</span> <span class="kr">Bool</span> <span class="o">|</span> <span class="kr">String</span>
</code></pre>
<p>The Inkling set of primitive types includes numeric, string, and boolean types.</p>

<aside class="warning">
String is not yet implemented.
</aside>

<p>In the code panel you will see the set of primitive types which are used in schema declarations. </p>

<p>The integer suffix indicates the size in bits of the type. </p>

<p>Integer types beginning with &lsquo;U&rsquo; are unsigned. </p>

<p><code class="prettyprint">Double</code> and <code class="prettyprint">Float64</code> are synonyms.</p>

<h6 id="structured-types">Structured Types</h6>

<blockquote>
<p>Structured Types List</p>
</blockquote>
<pre class="highlight inkling tab-inkling--syntax"><code><span class="nx">structure_type</span> <span class="p">::</span><span class="o">=</span>                      <span class="c1"># syntax</span>
  <span class="kr">Luminance</span> 
  <span class="o">|</span> <span class="kr">Matrix</span>
</code></pre><pre class="highlight inkling tab-inkling--code"><code><span class="k">schema</span> <span class="nx">BallLocationSchema</span>               <span class="c1"># example</span>
  <span class="kr">Luminance</span><span class="p">(</span><span class="mi">84</span><span class="p">,</span> <span class="mi">336</span><span class="p">)</span> <span class="nx">pixels</span><span class="p">,</span>    
  <span class="kr">Matrix</span><span class="p">(</span><span class="kr">UInt32</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="nx">location</span> 
<span class="k">end</span>
</code></pre>
<p>Structured types in Inkling are intended to support common
Machine Learning types. The only Machine Learning type currently supported is
<code class="prettyprint">Luminance</code>. This support will be expanded to <code class="prettyprint">Matrix</code> and <code class="prettyprint">Vector</code>, among
others in the future.</p>

<aside class="warning">
Matrix and Vector are not yet implemented.
</aside>

<h6 id="constrained-types-and-range-expressions">Constrained Types and Range Expressions</h6>
<pre class="highlight inkling tab-inkling--code"><code>  <span class="k">schema</span> <span class="nx">my_schema</span>
    <span class="kr">Int32</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">}</span> <span class="nx">z</span>            <span class="c1"># primitive type with type constraint</span>
  <span class="k">end</span>
</code></pre>
<p>A constrained type is a type which is associated with a constraint.
The type plus constraint is effectively a set definition. 
A field declared with a
constrained type can only take values that are a member of the set defined by
the constraint. In the example in the code panel, the field <code class="prettyprint">z</code> can only take on
values between <code class="prettyprint">1</code> and <code class="prettyprint">5</code>. </p>

<p>Constrained types are supported in schemas and in lesson clauses. Types are
constrained by means of <strong>range expressions</strong>.
A range expression on a type has the effect of constraining the values of the type to values defined by the range expression. </p>

<ul>
<li>In a schema the range expression constrains the values in the field. </li>
<li>In lessons the range expression constrains the values of the placeholder being configured.</li>
</ul>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">schema</span> <span class="nx">MyOutput</span> 
   <span class="kr">UInt8</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">}</span>    <span class="nx">label</span><span class="p">,</span>       <span class="c1"># a list of UInt8 values</span>
   <span class="kr">Int64</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span><span class="mi">100</span><span class="p">}</span>      <span class="nx">x</span><span class="p">,</span>           <span class="c1"># start:step:stop, step= 5, 0..100</span>
   <span class="kr">Int64</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="mi">100</span><span class="p">}</span>        <span class="nx">y</span><span class="p">,</span>           <span class="c1"># start:stop, step= 1, 0..100</span>
   <span class="kr">Int64</span> <span class="p">{</span><span class="mi">0</span><span class="p">..</span><span class="mi">100</span><span class="p">:</span><span class="mi">25</span><span class="p">}</span>    <span class="nx">z</span><span class="p">,</span>           <span class="c1"># start:stop, numsteps=25, step= 4, 0..100</span>
   <span class="kr">Float32</span> <span class="p">{</span><span class="mi">0</span><span class="p">..</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">}</span>     <span class="nx">a</span>            <span class="c1"># gives (0, .5., 1.0, 1.5, 2.0)</span>
<span class="k">end</span>
</code></pre>
<p>The syntax for a constrained type is the same for schema fields and placeholder expressions.</p>

<p>In the code panel are some examples of type constraints as they could appear in a schema definition. Curly braces delineate the range expression.</p>

<p>Inkling supports <strong>numeric range expressions</strong> and <strong>value list range
expressions</strong>. </p>

<h6 id="numeric-range-expressions">Numeric Range Expressions</h6>

<blockquote>
<p>Numeric Range Expression Syntax</p>
</blockquote>
<pre class="highlight inkling tab-inkling--syntax"><code> <span class="kr">Double</span> <span class="o">|</span> <span class="kr">Float64</span> <span class="o">|</span> <span class="kr">Float32</span> <span class="o">|</span> <span class="kr">Int8</span> <span class="o">|</span> <span class="kr">Int16</span> <span class="o">|</span> <span class="kr">Int32</span> <span class="o">|</span> <span class="kr">Int64</span> <span class="o">|</span> <span class="kr">UInt8</span> <span class="o">|</span> <span class="kr">UInt16</span> <span class="o">|</span> <span class="kr">UInt32</span> <span class="o">|</span> <span class="kr">UInt64</span>
  <span class="p">'{'</span> 
      <span class="nx">start</span> <span class="p">':'</span> <span class="p">[</span> <span class="nx">step</span><span class="p">':']?</span> <span class="nx">stop</span>       <span class="c1"># 'colon range'</span>
      <span class="o">|</span>  
      <span class="nx">start</span> <span class="p">'.'</span> <span class="p">'.'</span> <span class="nx">stop</span> <span class="p">':'</span> <span class="nx">numSteps</span>  <span class="c1"># 'dot range'</span>
  <span class="p">'}'</span> 
</code></pre>
<p>For numeric range expressions there are two types: </p>

<ul>
<li><strong>colon range</strong> </li>
<li><strong>dot range</strong> </li>
</ul>

<p>A <strong>dot range</strong> must specify numSteps. numSteps must be a positive integer constant. Today, <strong>dot range</strong> expressions cannot be used in <code class="prettyprint">predicts</code> schemas with <code class="prettyprint">is estimator</code> concepts. </p>

<p>A <strong>colon range</strong> can specifies an optional <strong>step size</strong>. If step size is omitted, the range includes all values of the given type between <strong>start</strong> and <strong>end</strong>. For example, in <strong>colon range</strong> expressions with integer types, if an explicit step is not specified, the default step size is 1.</p>

<p>Step size is required for FloatXX fields in the output schemas for <code class="prettyprint">is classifier</code> concepts. </p>

<p>Note that today, all fields in schemas used in the predicts clause of <code class="prettyprint">is estimator</code> concepts must have type FloatXX with no explicit step.</p>

<h3 id="usage">Usage</h3>

<p>For some ranges, it is clearer to specify the number of steps in the
range then the step size. For example <code class="prettyprint">Int32{-11003..743299:100}</code> makes it clear 
that a large range has 100 elements. Using step size for such a range would not
clearly communicate that information. </p>

<p>In other contexts, the step size is of interest, and we use the colon range. For
example, in the range <code class="prettyprint">Int32{0:2:10}</code>, we have divided the range into elements (0,2,4,6,8,10).
The step size of two communicates information about the distribution of values
in the range. </p>
<pre class="highlight inkling tab-inkling--code"><code><span class="kr">Int64</span>  <span class="p">{</span> <span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">1</span> <span class="p">}</span>     <span class="c1"># is invalid. The step size is larger than the range.</span>
<span class="kr">Int64</span>  <span class="p">{</span> <span class="mi">0</span><span class="p">..</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span> <span class="p">}</span>    <span class="c1"># is invalid. Values generated are floating point not integer. </span>
<span class="kr">Float32</span><span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">..</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span> <span class="p">}</span>   <span class="c1"># is valid. Negative bounds allowed.</span>
<span class="kr">Int8</span>   <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">4</span><span class="p">:</span><span class="o">-</span><span class="mi">100</span><span class="p">}</span>   <span class="c1"># is valid. stop &lt; start is valid if and only if step is negative. </span>
<span class="kr">UInt32</span> <span class="p">{</span><span class="o">-</span><span class="mi">10</span><span class="p">:</span><span class="mi">10</span><span class="p">}</span>      <span class="c1"># is invalid. Unsigned integer range contains signed values.</span>
</code></pre>
<p>The code panel contains some examples of valid and invalid ranges. </p>

<p>For <strong>colon range</strong>, step can be a floating point number. </p>

<p>For <strong>dot range</strong>, number of steps (numSteps) must be a positive integer.</p>

<p>For <strong>colon range</strong>, the step size can be negative only if stop is less than start.</p>

<p>For both <strong>colon range</strong> and <strong>dot range</strong>:</p>

<ul>
<li><p>The <strong>start point</strong> is inclusive (it is included in the values of the range) and fixed. </p></li>
<li><p>The <strong>start point</strong> is exact (to the maximum extent possible if the range expression type is floating point). </p></li>
<li><p>The <strong>end point</strong> must be reachable from the range start by applying the step. (The range must be bounded.) </p></li>
<li><p>The <strong>end point</strong> may or may not be included in the values of the range. If you
land on it exactly it is in the range. If you don&rsquo;t land on it exactly it is not
in the range. For example <code class="prettyprint">Int8 {0:3:10}</code> gives you (0, 3, 6, 9). The end point
<code class="prettyprint">10</code> is not included. The specification of <code class="prettyprint">10</code> as the stop point is not an error (because it is a limit, not an endpoint). </p></li>
</ul>

<p>You can think of the <strong>end point</strong> as a limit. It is included only if, after
applying the (step or numSteps) expression, you land on it exactly. 
Otherwise the highest value landed on which is less than the end point is the final value in the range. </p>

<h6 id="value-list-range-expressions">Value List Range Expressions</h6>

<p> </p>

<blockquote>
<p>Value List Range Expression Syntax</p>
</blockquote>
<pre class="highlight inkling tab-inkling--syntax"><code><span class="nx">primitiveType</span> 
    <span class="p">'{'</span> 
        <span class="p">[</span> <span class="nx">integerLiteral</span> <span class="p">[</span> <span class="p">','</span> <span class="nx">integerLiteral</span> <span class="p">]</span><span class="o">*</span> <span class="p">]</span>
     <span class="o">|</span>  <span class="p">[</span> <span class="nx">floatLiteral</span> <span class="p">[</span> <span class="p">','</span> <span class="nx">floatLiteral</span> <span class="p">]</span><span class="o">*</span> <span class="p">]</span>
     <span class="o">|</span>  <span class="p">[</span> <span class="nx">booleanLiteral</span> <span class="p">[</span> <span class="p">','</span> <span class="nx">booleanLiteral</span> <span class="p">]?</span> <span class="p">]</span>
    <span class="p">'}'</span> 
</code></pre>
<p>Inkling supports range expressions for value lists. </p>

<p>A value list range
expression can be defined for numeric types
and the primitive type <code class="prettyprint">Bool</code>.</p>

<h3 id="usage">Usage</h3>
<pre class="highlight inkling tab-inkling--code"><code>    <span class="kr">UInt8</span>  <span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">}</span>             <span class="c1"># is valid.</span>
    <span class="kr">UInt8</span>  <span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">}</span>            <span class="c1"># is invalid (negative integer in unsigned range).</span>
</code></pre>
<p>Value list range expressions support allowing arbitrary lists of values to constitute the
range expression set, rather than start and end points. </p>

<p>A value list range expression must have all its elements be valid values for the
specified type. </p>

<p>A value list range expression must conform to the signed or unsigned attribute
of the specified type (if there is such an attribute). </p>

<h6 id="schema-matching">Schema Matching</h6>

<p>Inkling uses schemas to understand and interpret the data format of streams.  The Inkling compiler performs schema match checking and will report errors if schemas which are expected to match do not. </p>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">schema</span> <span class="nx">GameState</span>
  <span class="kr">Luminance</span><span class="p">(</span><span class="mi">84</span><span class="p">,</span> <span class="mi">336</span><span class="p">)</span> <span class="nx">pixels</span>
<span class="k">end</span>
<span class="err"> </span>
<span class="k">concept</span> <span class="nx">keep_paddle_under_ball</span> 
  <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="p">(</span><span class="nx">PlayerMove</span><span class="p">)</span>
  <span class="k">follows</span> <span class="nx">ball_location</span><span class="p">,</span> 
          <span class="kr">input</span><span class="p">(</span><span class="nx">GameState</span><span class="p">)</span>           <span class="c1"># &lt;--- (1) MATCH </span>
<span class="k">end</span>
<span class="err"> </span>
<span class="k">concept</span> <span class="nx">high_score</span> 
  <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="p">(</span><span class="nx">PlayerMove</span><span class="p">)</span>
  <span class="k">follows</span> <span class="nx">keep_paddle_under_ball</span><span class="p">,</span> 
          <span class="kr">input</span><span class="p">(</span><span class="nx">GameState</span><span class="p">)</span>           <span class="c1"># &lt;--- (1) MATCH </span>
  <span class="k">feeds</span> <span class="kr">output</span>
<span class="k">end</span>
<span class="err"> </span>
<span class="k">concept</span> <span class="nx">ball_location</span> 
  <span class="k">is</span> <span class="nx">estimator</span>
  <span class="k">predicts</span> <span class="p">(</span><span class="kr">Matrix</span><span class="p">(</span><span class="kr">UInt32</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="nx">location</span><span class="p">)</span>
  <span class="k">follows</span> 
    <span class="kr">input</span><span class="p">(</span><span class="kr">Luminance</span><span class="p">(</span><span class="mi">84</span><span class="p">,</span> <span class="mi">336</span><span class="p">)</span> <span class="nx">pixels</span><span class="p">)</span> <span class="c1"># &lt;--- (2) MATCH</span>
<span class="k">end</span>
<span class="err"> </span>
<span class="k">concept</span> <span class="nx">ball_X_location</span> <span class="k">is</span> <span class="nx">estimator</span>
  <span class="k">predicts</span> <span class="p">(</span><span class="nx">Uint32</span> <span class="nx">X_location</span><span class="p">)</span>
  <span class="k">follows</span> 
    <span class="kr">input</span><span class="p">(</span><span class="kr">Luminance</span><span class="p">(</span><span class="mi">84</span><span class="p">,</span> <span class="mi">330</span><span class="p">)</span> <span class="nx">pixels</span><span class="p">)</span> <span class="c1"># &lt;--- (3) NO MATCH</span>
<span class="k">end</span>
</code></pre>
<p>Matching for schemas is both structural and name based. Field names matter.
Types matter.</p>

<ul>
<li>Two references by name to the same schema match because a schema matches itself. </li>
<li>Two references to different schema names match if both schemas define the same list of field types in the same order with the same names. For structured types whose declaration includes size, the sizes must be equal.</li>
<li>Two anonymous schemas match if both define the same field types in the same order with the same names. </li>
<li>A schema referenced by name matches an anonymous schema if both define the same field types in the same order with the same names. </li>
</ul>

<p>The associated example shows successful schema matching and failed schema matching. 
The rule being checked is that all uses of <code class="prettyprint">input</code> use the same schema. </p>

<ul>
<li>(1) shows a valid schema match by name (for <code class="prettyprint">input</code>). </li>
<li>(2) shows a valid match by field type, field name, and size (for <code class="prettyprint">input</code>). </li>
<li>(3) shows a failed match (size is not equal, for <code class="prettyprint">input</code>). </li>
</ul>

<p>Every Inkling program has the predefined stream <code class="prettyprint">input</code> available to it. Since there is a single stream associated with the keyword <code class="prettyprint">input</code>, there can be only one definition of the data format of that stream. Once defined, the data format of a stream cannot change dynamically.  If that schema changes inkling compiler will flag that change as an error. Thus any reference to the <code class="prettyprint">input</code> stream must have a schema that matches all other schemas used with the <code class="prettyprint">input</code> stream. </p>

<h6 id="constraint-compatibility-in-the-lesson-configure-clause">Constraint Compatibility in the Lesson Configure Clause</h6>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">simulator</span> <span class="nx">breakout_simulator</span><span class="p">(</span><span class="nx">BreakoutConfig</span><span class="p">)</span>
   <span class="k">state</span> <span class="p">(</span><span class="nx">GameState</span><span class="p">)</span>
   <span class="k">action</span><span class="p">(</span><span class="nx">PlayerMove</span><span class="p">)</span>
<span class="nx">End</span>
<span class="err"> </span>
<span class="k">schema</span> <span class="nx">BreakoutConfig</span>
  <span class="kr">UInt32</span> <span class="nx">level</span><span class="p">,</span>
  <span class="kr">UInt8</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">}</span> <span class="nx">paddle_width</span><span class="p">,</span>
  <span class="kr">Float32</span> <span class="nx">bricks_percent</span>
<span class="k">end</span>
<span class="err"> </span>
<span class="k">curriculum</span> <span class="nx">ball_location_curriculum</span>
  <span class="k">train</span> <span class="nx">ball_location</span>
  <span class="k">with</span> <span class="k">simulator</span> <span class="nx">breakout_simulator</span>
  <span class="k">objective</span> <span class="nx">ball_location_distance</span>

    <span class="k">lesson</span> <span class="nx">more_bricks</span> <span class="k">follows</span> <span class="nx">no_bricks</span>
      <span class="k">configure</span>
        <span class="k">constrain</span> <span class="nx">bricks_percent</span> <span class="k">with</span> <span class="kr">Float32</span><span class="p">{</span><span class="mf">0.1</span><span class="p">:</span><span class="mf">0.01</span><span class="p">:</span><span class="mf">1.0</span><span class="p">},</span>
        <span class="k">constrain</span> <span class="nx">level</span> <span class="k">with</span> <span class="kr">UInt32</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">100</span><span class="p">},</span>
        <span class="k">constrain</span> <span class="nx">paddle_width</span> <span class="k">with</span> <span class="kr">UInt8</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">}</span>
      <span class="k">train</span>
        <span class="k">from</span> <span class="nx">frame</span> <span class="k">in</span> <span class="nx">breakout_simulator</span>
        <span class="k">select</span> <span class="nx">frame</span>
        <span class="k">send</span> <span class="nx">frame</span>
      <span class="k">test</span>
        <span class="k">from</span> <span class="nx">frame</span> <span class="k">in</span> <span class="nx">breakout_simulator</span>
        <span class="k">select</span> <span class="nx">frame</span>
        <span class="k">send</span> <span class="nx">frame</span>
      <span class="k">until</span>
        <span class="k">minimize</span> <span class="nx">ball_location_distance</span>
<span class="k">end</span>
</code></pre>
<p>Constraints can be specified in the lesson configure clause. 
These constraints must be compatible with the configuration schema of the
associated simulator. 
The code panel contains some Inkling code from the breakout program to show an example. </p>

<p>The constraints in a lesson configure clause are constraints on the fields of
the configuration schema of the simulator.
Here, the lesson configure constraints are constraining the fields of schema <code class="prettyprint">BreakoutConfig</code>.</p>

<p>Given simulator <code class="prettyprint">breakout_simulator</code>, the constraints in the lesson configure section must have these characteristics to be compatible with schema <code class="prettyprint">BreakoutConfig</code>:</p>

<ol>
<li>They must specify exactly the same type and field name as the schema declaration. A constraint cannot use an Int8 where a UInt32 was originally specified.</li>
<li>For the range expression, the range in the configure must specify exactly the same range or a subrange as the schema declaration.</li>
<li>Step size or numSteps should not be specified in the configuration schema of
the simulator. They can be specified in the lesson configure clause.
Specifically, in the <code class="prettyprint">BreakoutConfig</code> schema above, <code class="prettyprint">UInt8{1:4} paddle_width</code> is valid but <code class="prettyprint">UInt8{1:2:4} paddle_width</code> would not be valid.</li>
</ol>

<p>Here is the constraint for <code class="prettyprint">level</code> that is specified in the lesson <code class="prettyprint">more_bricks</code> configure clause:</p>

<p><code class="prettyprint">constrain level with UInt32{1:100}</code></p>

<p>Here is the constraint for <code class="prettyprint">level</code> in the simulator configuration schema <code class="prettyprint">BreakoutConfig</code>:</p>

<p><code class="prettyprint">UInt32 level</code></p>

<blockquote>
<p>Examples of valid constraints:</p>
</blockquote>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">constrain</span> <span class="nx">paddle_width</span> <span class="k">with</span> <span class="kr">UInt8</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">}</span>    <span class="c1"># ok: a subset of constraint set</span>

<span class="k">constrain</span> <span class="nx">paddle_width</span> <span class="k">with</span> <span class="kr">UInt8</span><span class="p">{</span><span class="mi">2</span><span class="p">}</span>      <span class="c1"># ok: value in constraint set</span>
</code></pre>
<blockquote>
<p>Examples of invalid constraints</p>
</blockquote>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">constrain</span> <span class="nx">paddle_width</span> <span class="k">with</span> <span class="kr">UInt8</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">}</span>    <span class="c1"># not a subset of constraint set</span>

<span class="k">constrain</span> <span class="nx">paddle_width</span> <span class="k">with</span> <span class="kr">UInt8</span><span class="p">{</span><span class="mi">7</span><span class="p">}</span>      <span class="c1"># value not in constraint set</span>
</code></pre>
<p>The lesson configure clause constraint is compatible with the simulator
configuration constraint because the latter declared
no range at all and any range expression is a subrange of all the values
available to a type. </p>

<p>The field <code class="prettyprint">paddle_width</code> in the simulator configuration schema <code class="prettyprint">BreakoutConfig</code>
does specify a range expression: </p>

<p><code class="prettyprint">UInt8{1:4} paddle_width</code></p>

<p>The corresponding range expression in the lesson configure clause is identical:</p>

<p><code class="prettyprint">constrain paddle_width with UInt8{1:4}</code></p>

<p>These are compatible.</p>

<p>In the examples in the code panel, we show more examples of valid and invalid lesson
configure constraints for the field <code class="prettyprint">paddle_width</code>.</p>

          <h1 id="simulators">Simulators</h1>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">simulator</span> <span class="nx">MySimulator</span><span class="p">(</span><span class="nx">MySchemaConfig</span><span class="p">)</span>
  <span class="k">state</span> <span class="p">(</span><span class="nx">MyStateSchema</span><span class="p">)</span>
  <span class="k">action</span> <span class="p">(</span><span class="nx">MyActionSchema</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<p>Curriculum statements reference an associated simulator in the <a href="#curriculums">with clause</a>. Each
simulator used in a curriculum must be declared in a <code class="prettyprint">simulator</code> statement.  </p>

<p>The <code class="prettyprint">simulator</code> statement describes the interface to a simulator. Simulators are
generally implemented in python or C++. The Inkling program does not contain
code for the simulator itself. Instead the Inkling program defines how the
simulator is used to train Inkling concepts.</p>

<blockquote>
<p>Simulator Clause Syntax</p>
</blockquote>
<pre class="highlight inkling tab-inkling--syntax"><code><span class="k">simulator</span> <span class="o">&lt;</span><span class="nx">simulatorName</span><span class="o">&gt;</span><span class="p">'('</span><span class="o">&lt;</span><span class="nx">configurationSchema</span><span class="o">&gt;</span><span class="p">')'</span> 
  <span class="k">state</span> <span class="p">'('</span><span class="o">&lt;</span><span class="nx">stateSchema</span><span class="o">&gt;</span><span class="p">')'</span>     <span class="c1"># simulator state</span>
  <span class="nx">control</span> <span class="p">'('</span><span class="o">&lt;</span><span class="nx">controlSchema</span><span class="o">&gt;</span><span class="p">')'</span> <span class="c1"># training concept predicts schema</span>
<span class="k">end</span>
</code></pre>
<p>A <code class="prettyprint">simulator</code> statement associates a set of schemas with the simulator. </p>

<ul>
<li>The configuration schema is used for initialization. </li>
<li>The action schema describes the simulator input.</li>
<li>The state schema describes the simulator output.</li>
</ul>

<h3 id="usage">Usage</h3>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">curriculum</span> <span class="nx">ball_location_curriculum</span>
  <span class="k">train</span> <span class="nx">ball_location</span>
  <span class="k">with</span> <span class="k">simulator</span> <span class="nx">breakout_simulator</span>
  <span class="k">objective</span> <span class="nx">ball_location_distance</span>
  <span class="p">...</span> 
</code></pre>
<p>The curriculum specifies which simulator it uses. The example in the code panel
shows the use of simulator <code class="prettyprint">breakout_simulator</code>. </p>

<h3 id="discussion">Discussion</h3>

<p>Simulators are virtual environments designed to simulate a real world situation
or problem. Every simulator has a state, a representation of the world inside the
virtual environment. This state changes over time in response to actions taken
by an agent. </p>

<p>The simulator and the BRAIN are in a loop where a BRAIN is receiving a frame 
of state from the simulator, followed by the BRAIN selecting a next action. 
The simulator then changes state in response to that action. The BRAIN then
receives this new updated frame of state from the simulator and selects a new
next action, so on and so on, until the BRAIN learns how to best operate the simulation.</p>

<p>Our <a href="library-reference.html">Library Reference</a> describes the classes and methods used to connect an existing simulator or create a new simulator in Python. <a href="../examples.html#basic-simulator-find-the-center">Find the Center</a> is an example of a basic simulator implementation.</p>

<h3 id="example">Example</h3>
<pre class="highlight inkling tab-inkling--code"><code>
<span class="k">simulator</span> <span class="nx">breakout_simulator</span><span class="p">(</span><span class="nx">BreakoutConfig</span><span class="p">)</span>
  <span class="k">action</span>  <span class="p">(</span><span class="nx">PlayerMove</span><span class="p">)</span>
  <span class="k">state</span> <span class="p">(</span><span class="nx">GameState</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">schema</span> <span class="nx">GameState</span>
  <span class="kr">Luminance</span><span class="p">(</span><span class="mi">84</span><span class="p">,</span> <span class="mi">336</span><span class="p">)</span> <span class="nx">pixels</span>
<span class="k">end</span>

<span class="k">schema</span> <span class="nx">PlayerMove</span>
  <span class="kr">Int8</span><span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span> <span class="nx">move</span>
<span class="k">end</span>

<span class="k">schema</span> <span class="nx">BreakoutConfig</span>
  <span class="kr">UInt32</span> <span class="nx">level</span><span class="p">,</span>
  <span class="kr">UInt8</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">}</span> <span class="nx">paddle_width</span><span class="p">,</span>
  <span class="kr">Float32</span> <span class="nx">bricks_percent</span>
<span class="k">end</span>

<span class="k">concept</span> <span class="nx">high_score</span> <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="p">(</span><span class="nx">PlayerMove</span><span class="p">)</span>
  <span class="k">follows</span> <span class="kr">input</span><span class="p">(</span><span class="nx">GameState</span><span class="p">)</span>
  <span class="k">feeds</span> <span class="kr">output</span>
<span class="k">end</span>

<span class="k">curriculum</span> <span class="nx">high_score_curriculum</span>
  <span class="k">train</span> <span class="nx">high_score</span>
  <span class="k">with</span> <span class="k">simulator</span> <span class="nx">breakout_simulator</span>
  <span class="k">objective</span> <span class="nx">score</span>
    <span class="k">lesson</span> <span class="nx">score_lesson</span>
      <span class="k">configure</span>
        <span class="k">constrain</span> <span class="nx">bricks_percent</span> <span class="k">with</span> <span class="kr">Float32</span><span class="p">{</span><span class="mf">1.0</span><span class="p">},</span>
        <span class="k">constrain</span> <span class="nx">level</span> <span class="k">with</span> <span class="kr">UInt32</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">100</span><span class="p">},</span>
        <span class="k">constrain</span> <span class="nx">paddle_width</span> <span class="k">with</span> <span class="kr">UInt8</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">}</span>
      <span class="k">train</span>
        <span class="k">from</span> <span class="nx">frame</span> <span class="k">in</span> <span class="nx">breakout_simulator</span>
        <span class="k">select</span> <span class="nx">frame</span>
        <span class="k">send</span> <span class="nx">frame</span>
      <span class="k">test</span>
        <span class="k">from</span> <span class="nx">frame</span> <span class="k">in</span> <span class="nx">breakout_simulator</span>
        <span class="k">select</span> <span class="nx">frame</span>
        <span class="k">send</span> <span class="nx">frame</span>
      <span class="k">until</span>
        <span class="k">maximize</span> <span class="nx">score</span>
<span class="k">end</span>
</code></pre>
<p>In this example we show some of the Inkling code for training the game Breakout.
The curriculum <code class="prettyprint">with</code> clause specifies <code class="prettyprint">breakout_simulator</code>, and the
<code class="prettyprint">simulator</code> statement specifies the action, state, and configuration schemas. </p>

<p>The curriculum specifies the <code class="prettyprint">objective</code> function, in this case it is
<code class="prettyprint">score</code>. The <code class="prettyprint">objective</code> function (which is sometimes called 
the reward function in the literature) is implemented in the simulator. 
(Eventually implementing objective functions in Inkling will be supported.)</p>

      </div>
      <div class="dark-box">
      </div>
    </div>

    </div>

  </div>
  <!-- at the end of the BODY -->
  <script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
  <script type="text/javascript"> docsearch({
  apiKey: '49fa6f01d7ff94a85b9b7434b1c2b7cf',
  indexName: 'bon-sai',
  inputSelector: '#docs-search',
  debug: false // Set debug to true if you want to inspect the dropdown
  });
  </script>
  </body>
</html>
